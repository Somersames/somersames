---
title: 数据库调优(一)
date: 2019-06-09 23:42:31
tags: [Mysql]
categories: Mysql
---
在上一篇文章中，我们有一个表，里面的内容如下：
```sql
mysql> select * from org_copy;
+--------+-----------------+---------------+----------+
| org_id | org_name        | org_parent_id | org_copy |
+--------+-----------------+---------------+----------+
|      1 | 一级部门        |             0 | 1        |
|      2 | 一一级部门      |             0 | 2        |
|      3 | 1.1级部门       |             1 | 3        |
|      4 | 1.2级部门       |             1 | 4        |
|      5 | 1.1.1部门       |             3 | 5        |
|      6 | 1.1.2部门       |             3 | 6        |
|      7 | 1.1.1.1部门     |             5 | 7        |
|      8 | 1.3部门         |             1 | 8        |
|      9 | 1.2.1部门       |             4 | 9        |
+--------+-----------------+---------------+----------+
9 rows in set (0.00 sec)

```
这应该是一个很基本的一个mysql表了，同时我们在上一篇文章中，也执行了如下SQL。

```sql
mysql> explain SELECT * FROM org_copy WHERE org_name>'一级部门' and  org_parent_id=1;
+----+-------------+----------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
| id | select_type | table    | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+----------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | org_copy | NULL       | range | index_name    | index_name | 768     | NULL |    1 |    11.11 | Using index condition |
+----+-------------+----------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)

```
可以看到此时确实走了索引，这个时候如果仔细想想会不会有点疑问呢？按照mysql最左原则的理论，其实在这里是无法走索引进行查询的，因为`org_name`是联合索引开头的一列并且`org_name`同时也进行了非等值查询，这就会导致这个联合索引失效，那么为什么还会走索引呢?这个跟索引覆盖有关系

```sql
mysql> explain SELECT * FROM org_copy WHERE org_name>'1' and  org_parent_id=1;
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | org_copy | NULL       | ALL  | index_name    | NULL | NULL    | NULL |    9 |    11.11 | Using where |
+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```
此时是不是会一脸疑惑...为啥我的这个SQL，明明一样呀，但是为啥第一个就不走索引呢???
其实因为在mysql里面，mysql会判断`当前where条件查询的数据量`，在mysql里面，索引是由一个`B+`树的形式存在，那么很明显，当我通过`org_name`来进行比较筛选的时候，我是可以很快的定位出大致需要查询的数据量。

在`mysql`里面，大概是30%以上的数据量就会采用全表扫描，