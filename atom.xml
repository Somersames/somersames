<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Somersames</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://somersames.github.io/"/>
  <updated>2021-04-10T13:29:32.882Z</updated>
  <id>https://somersames.github.io/</id>
  
  <author>
    <name>Somersames</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring ContentNegotiation（内容协商）之使用篇（一）</title>
    <link href="https://somersames.github.io/2021/04/07/talk-about-httpMessageConvert/"/>
    <id>https://somersames.github.io/2021/04/07/talk-about-httpMessageConvert/</id>
    <published>2021-04-06T16:11:11.000Z</published>
    <updated>2021-04-10T13:29:32.882Z</updated>
    
    <content type="html"><![CDATA[<!-- 提纲：一旦匹配不到就会走默认逻辑，具体的处理逻辑是之所以配置文件请求url为json1，也可以返回json，是因为没有指定默认的返回格式，但是spring的默认是 */*，而spring的 json 的 convert 恰好又可以解析这种格式，所以就会导致除非可以匹配到，没有匹配到的全部都会转为json当配置了第二种方式以后会通过 ParameterContentNegotiationStrategy 来解析Parameter发现的另一个坑不要开启 @EnableMVC，否则会导致mvc的部分配置失效 --><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着业务系统的成熟，如果你的项目正好是公司的中台战略之一，但是下游系统的接收方式不统一，这一种情况在一些老的公司系统架构总经常出现，如果下游系统不方便兼容，那么就需要中台系统对外提供各种不同格式返回报文</p><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>简单说就是服务提供方根据客户端所支持的格式来返回对应的报文，在 Spring 中，REST API 基本上都是以 json 格式进行返回，而如果需要一个接口即支持 json，又支持其他格式，开发和维护多套代码显然是不合理的，而 Spring 又恰好提供了该功能，那便是ContentNegotiation</p><p>在 Spring 中，决定一个数据是以 json、xml 还是 html 的方式返回有三种方式，分别如下：</p><blockquote><p>1：favorPathExtension 后缀模式，例如：xxx.json，xxx.xml<br>2：favorParameter format模式，例如：xxx?format=json,xxx?format=xml,<br>3：通过请求的 Accept 来决定返回的值</p></blockquote><p>在这三种模式中，前面两种模式都是关闭，如果需要打开，可以通过以下方式来开启<br>1：重写 <code>WebMvcConfigurer</code>(Spring5.X以后推荐的实现类) 的 <code>configureContentNegotiation</code> 来设置为 true 即可<br>2：设置 spring.mvc.contentnegotiation.favor-path-extension=true 或者 pring.mvc.contentnegotiation.favor-parameter=true</p><blockquote><p>tips:如果是使用 Spring2.X以上的版本，不要开启 @EnableWebMvc 注解，否则会导致你的配置无效，如果需要开启该注解，则只能使用方法一重写 WebMvcConfigurer 了</p></blockquote><h1 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h1><h2 id="1：favorPathExtension-后缀模式"><a href="#1：favorPathExtension-后缀模式" class="headerlink" title="1：favorPathExtension 后缀模式"></a>1：favorPathExtension 后缀模式</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  mvc:</span></span><br><span class="line"><span class="attr">    contentnegotiation:</span></span><br><span class="line"><span class="attr">      favor-path-extension:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      media-types:</span></span><br><span class="line"><span class="attr">        json:</span> <span class="string">application/json</span></span><br></pre></td></tr></table></figure><p>favor-path-extension 表示是否开启后缀匹配，media-types 表示后缀以何种方式进行解析，在这里需要注意一下一定是需要有对应的 HttpMessageConvert 才能解析，否则是会提示 <code>406 Could not find acceptable representation</code></p><blockquote><p>在 Spring 中已经默认含有json解析的 HttpMessageConvert，所以是可以直接解析的，如果需要支持解析 xml，可以引入 xml 包</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当开启了后缀模式以后，返回的文本类型会根据你的入参做不同的处理，.json 会返回 json 格式的数据，.xml 会返回 xml 格式的数据，当然也可以自定义一个 HttpMessageConverter 来自定义的返回文本格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET localhost:8081/controller/advice/decrypt.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "name": "a",</span><br><span class="line">    "age": 1,</span><br><span class="line">    "date": null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET localhost:8081/controller/advice/decrypt.xml</span><br><span class="line"></span><br><span class="line">&lt;Advice&gt;</span><br><span class="line">    &lt;name&gt;a&lt;/name&gt;</span><br><span class="line">    &lt;age&gt;1&lt;/age&gt;</span><br><span class="line">    &lt;date/&gt;</span><br><span class="line">&lt;/Advice&gt;</span><br></pre></td></tr></table></figure><h2 id="2：favorParameter"><a href="#2：favorParameter" class="headerlink" title="2：favorParameter"></a>2：favorParameter</h2><p>这种模式下是通过在 url 中通过一个参数来区分如何解析的，spring中已经默认这个关键字是 <code>format</code></p><p>修改配置文件如下：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  mvc:</span></span><br><span class="line"><span class="attr">    contentnegotiation:</span></span><br><span class="line"><span class="attr">      favor-parameter:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET localhost:8081/controller/advice/decrypt?format=json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "name": "a",</span><br><span class="line">    "age": 1,</span><br><span class="line">    "date": null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET localhost:8081/controller/advice/decrypt?format=xml</span><br><span class="line"></span><br><span class="line">&lt;Advice&gt;</span><br><span class="line">    &lt;name&gt;a&lt;/name&gt;</span><br><span class="line">    &lt;age&gt;1&lt;/age&gt;</span><br><span class="line">    &lt;date/&gt;</span><br><span class="line">&lt;/Advice&gt;</span><br></pre></td></tr></table></figure><p>当然也可以自己修改 parameter 的关键字，只需要在配置文件中调整下即可<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">parameter-name:</span> <span class="string">meida_type</span></span><br></pre></td></tr></table></figure></p><p>此时再次请求的时候 parameter 就需要调整为 meida_type，否则就会以默认的方式去解析返回的文本信息</p><h2 id="Accept解析"><a href="#Accept解析" class="headerlink" title="Accept解析"></a>Accept解析</h2><p>这种就是默认的一种解析方式，无需进行任何配置，Spring 就是默认以这种模式进行解析的<br>GET请求<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert/get_json.png" alt=""></p><p>XML请求<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/talkaboutHttpMeesageConvert/get_xml.png" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文只是简单的介绍了如何使用，后续会介绍原理篇</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- 
提纲：
一旦匹配不到就会走默认逻辑，具体的处理逻辑是
之所以配置文件请求url为json1，也可以返回json，是因为没有指定默认的返回格式，但是spring的默认是 */*，而spring的 json 的 convert 恰好又可以解析这种格式，所以就会导致除非可以
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊一聊 SpringBoot 中的一些被忽视的注解</title>
    <link href="https://somersames.github.io/2021/04/05/talk-about-springboot-anno/"/>
    <id>https://somersames.github.io/2021/04/05/talk-about-springboot-anno/</id>
    <published>2021-04-05T14:53:24.000Z</published>
    <updated>2021-04-06T14:18:44.502Z</updated>
    
    <content type="html"><![CDATA[<p>之前在老的项目中看到了一个比较有趣的现象</p><p>有一个需求是需要对返回的数据进行加解密的操作，部分老代码是直接硬编码在项目中，但是后来有人改了一版，称之为 1.0 版本</p><p>1.0 版本是通过切面配合注解进行处理，大致的处理流程是对返回的对象通过反射遍历字段，如果发现字段上有指定的注解，则进行加密操作，如果发现该字段是一个对象的话，则进行递归处理，直至结束</p><p>后来有一个需求是对返回的手机号、身份证信息只需要对中间的信息进行加密，两边不处理…其他的例如家庭地址、家庭成员全部加密为密文</p><p>拿到这个需求的时候，想改也挺简单，只需要增加一个新的注解，然后替换该切面扫描到的返回值进行替换注解就可以了</p><p>但是这样会导致切面里面的代码越来越臃肿，于是后来通过 <code>RestControllerAdvice</code> 进行了一个优化处理</p><p>今天就来聊一聊这两个被忽视的注解</p><h1 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h1><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/SpringBoot-Anno/ControllerAdvice.png" alt=""></p><p>通过上述的描述我们可以知道该注解是可以在多个 <code>Controller</code> 中共享一些操作，配合 <code>ExceptionHandler</code>、<code>InitBinder</code> 等，可以在请求数据进入 Controller 之前进行一个预处理，减少代码中的硬编码部分。</p><p>对于 <code>ExceptionHandler</code> 大家可能不会很陌生，一个通用的异常处理，如果项目不是纯 <code>dubbo</code> 对外提供接口的话，那么应该是会用到该注解的 </p><h2 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="ExceptionHandler"></a>ExceptionHandler</h2><p>这个注解可以定义一个全局的异常处理器，可以将指定的异常转换为约定的格式返回，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;BusinessException.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> JsonResponseResult <span class="title">handleRuntimeException</span><span class="params">(<span class="keyword">final</span> Exception re)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JsonResponseResult.error(XXX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，一旦 <code>Controller</code> 里面抛出了 BusinessException，于是返回自动就变成了这种自定义的 XXX</p><p>不用每一次都在 Controller 中手动捕获异常然后转换成 code，从业务的角度来说只需要区分各种异常，然后统一地方进行收口处理，尽最大的努力避免对业务代码的入侵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">code:1-99：参数问题</span><br><span class="line">code:2-199：权限不足</span><br><span class="line">XXX</span><br></pre></td></tr></table></figure><h2 id="InitBinder"><a href="#InitBinder" class="headerlink" title="InitBinder"></a>InitBinder</h2><p>该注解可以在请求参数进入 Controller 之前进行预处理，但是这个不能作用于 @RequestBody（这个注解是通过RequestBodyAdvice来生效的，不是同一个流程），这样就可以做一些比较好玩的操作了</p><h3 id="优势一："><a href="#优势一：" class="headerlink" title="优势一："></a>优势一：</h3><p>例如一个请求的 url 是 <code>localhost:8081/controller/testAdvice?advice=1-2</code></p><p>在业务中如果要接收这个参数是需要将 <code>advice</code> 定义为 String，那么如果想直接用对象来接收，会直接抛出一个异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/testAdvice"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAdvice</span><span class="params">(@RequestParam (name = <span class="string">"advice"</span>)</span>Advice advice)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> advice.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/SpringBoot-Anno/string_error.png" alt=""></p><p>如果非要用对象来接收，这个时候就可以通过 <code>InitBinder</code> 来实现了</p><blockquote><p>GlobalAdvice</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalAdvice</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Logger logger = LoggerFactory.getLogger(GlobalAdvice.class);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProduct</span><span class="params">(WebDataBinder webDataBinder, String advice)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"origin:&#123;&#125;"</span>,advice);</span><br><span class="line">        webDataBinder.registerCustomEditor(Advice.class,<span class="keyword">new</span> ProductEditor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ProductEditor</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductEditor</span> <span class="keyword">extends</span> <span class="title">PropertyEditorSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(text))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] strings = text.split(<span class="string">"-"</span>);</span><br><span class="line">        Advice advice = <span class="keyword">new</span> Advice();</span><br><span class="line">        advice.setName(strings[<span class="number">0</span>]);</span><br><span class="line">        advice.setAge(Integer.parseInt(strings[<span class="number">1</span>]));</span><br><span class="line">        setValue(advice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再次请求 <code>localhost:8081/controller/testAdvice?advice=1-2</code> 就会发现是正常展示了</p><h3 id="优势二"><a href="#优势二" class="headerlink" title="优势二"></a>优势二</h3><p>可以解析前端 form-data 提交过来信息，在对象处理之前进行格式化，避免出错<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/testAdvice2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAdvice2</span><span class="params">(Advice advice)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> advice.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(text))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 格式化，这里为了简单，直接new Date()</span></span><br><span class="line">    setValue(<span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时 Date 就会在这里统一格式化，十分的方便</p><h3 id="优势三"><a href="#优势三" class="headerlink" title="优势三"></a>优势三</h3><p>配合 Validator 来使用</p><p>通过实现 <code>Validator</code> 这个类来实现一些复杂的检验规则，例如要求年龄大于1岁的，必须要有姓名，在这个场景下普通的校验规则就无法满足的，所以这个时候可以自定一个规则<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(GlobalAdvice.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProduct</span><span class="params">(WebDataBinder webDataBinder, String advice)</span></span>&#123;</span><br><span class="line">        logger.info(<span class="string">"origin:&#123;&#125;"</span>,advice);</span><br><span class="line">        webDataBinder.registerCustomEditor(Advice.class,<span class="keyword">new</span> ProductEditor());</span><br><span class="line">        webDataBinder.registerCustomEditor(Date.class,<span class="keyword">new</span> DateEditor());</span><br><span class="line">        webDataBinder.setValidator(<span class="keyword">new</span> AdviceValidator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceValidator</span> <span class="keyword">implements</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Advice.class.equals(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors)</span> </span>&#123;</span><br><span class="line">        Advice advice = (Advice) target;</span><br><span class="line">        <span class="keyword">if</span>(advice.getAge() &gt;= <span class="number">1</span> &amp;&amp; StringUtils.isEmpty(advice.getName()))&#123;</span><br><span class="line">            errors.rejectValue(<span class="string">"name"</span>,<span class="string">"advice.name"</span>,<span class="string">"年龄大于1岁的，姓名不能为空"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时该注解也无需在实体类上面进行任何操作，很方便的进行扩展，通过配置中心，可以实现定制化的控制规则，方便运营及时的调整规则，实时生效</p><h1 id="RestControllerAdvice"><a href="#RestControllerAdvice" class="headerlink" title="@RestControllerAdvice"></a>@RestControllerAdvice</h1><p>官网的介绍如下：</p><blockquote><p>convenience annotation that is itself annotated with @ControllerAdvice and @ResponseBody</p></blockquote><p>表示这个注解包含了上面的 <code>ControllerAdvice</code> 以及 <code>ResponseBody</code>，</p><p>作用是可以对入参的 <code>@RequestBody</code>  和 <code>@ResponseBody</code> 进行处理，常见的如对返回数据加密等操作</p><p>例如刚才的 <code>Advice</code> 类，如果需要对其的 name 统计进行小写转大写（这里只是做展示，实际情况可能是对name进行加密操作），如果在业务代码中进行处理，那么会造成一种硬编码，</p><h2 id="ResponseBodyAdvice"><a href="#ResponseBodyAdvice" class="headerlink" title="ResponseBodyAdvice"></a>ResponseBodyAdvice</h2><blockquote><p>Allows customizing the response after the execution of an @ResponseBody or a esponseEntity controller method but before the body is written with an HttpMessageConverter</p></blockquote><p> 也就是说可以在 <code>HttpMessageConverter</code> 调用之前，对返回的对象进行处理，而 <code>HttpMessageConverter</code> 由于不在本文范畴，暂时忽略，但是需要记住这个类是将返回的对象处理成 json 的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> somersames</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER,ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DecryptInfo &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代表解密的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> "idCard"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecryptAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> returnType.hasMethodAnnotation(DecryptInfo.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(body <span class="keyword">instanceof</span> Advice)&#123;</span><br><span class="line">            Advice advice = (Advice) body;</span><br><span class="line">            advice.setName(advice.getName().toUpperCase());</span><br><span class="line">            <span class="keyword">return</span> advice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当定义好上述两个类以后，则只需要在方法上加上该注解即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/advice/decrypt"</span>)</span><br><span class="line"><span class="meta">@DecryptInfo</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advice <span class="title">testAdvice</span><span class="params">(@Validated @RequestBody Advice bodyAdvice)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bodyAdvice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时 name 就会被转为大写，如果需要对入参进行处理，实现 <code>RequestBodyAdvice</code> 即可，相同的道理</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在业务代码中，如果需要对 controller 层返回的数据进行加解密操作，有两种选择，一种是切面配合反射来遍历对象的字段判断是否包含指定的注解，如果含有的话，则直接进行加解密操作</p><p>还有一种就是今天的 <code>RestControllerAdvice</code> 扫描指定的包然后进行操作</p><p>如果是通过切面来进行处理，那么每一个返回的对象都必须明确的指明加解密的类型以及字段，需要配合注解使用，但是如果用 <code>RestControllerAdvice</code> 是否会是一个更好的选择呢？</p><p>显然，这两种方式个人认为切面比较不优雅，主要无法解耦，当需要扩展一个注解的功能时，会修改切面里面的代码，而且如果需要对返回的数据进行按照顺序处理，如果使用 <code>RestControllerAdvice</code>，那么直接使用 <code>@Order</code> 注解使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在老的项目中看到了一个比较有趣的现象&lt;/p&gt;
&lt;p&gt;有一个需求是需要对返回的数据进行加解密的操作，部分老代码是直接硬编码在项目中，但是后来有人改了一版，称之为 1.0 版本&lt;/p&gt;
&lt;p&gt;1.0 版本是通过切面配合注解进行处理，大致的处理流程是对返回的对象通过反射遍历字
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>夏令时的一些事</title>
    <link href="https://somersames.github.io/2020/08/24/%E5%A4%8F%E4%BB%A4%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>https://somersames.github.io/2020/08/24/夏令时的一些事/</id>
    <published>2020-08-24T15:26:39.000Z</published>
    <updated>2021-04-05T14:52:36.644Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis实现的分布式锁是完美的吗？</title>
    <link href="https://somersames.github.io/2020/08/03/Redis%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%98%AF%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%90%97%EF%BC%9F/"/>
    <id>https://somersames.github.io/2020/08/03/Redis实现的分布式锁是完美的吗？/</id>
    <published>2020-08-02T16:34:23.000Z</published>
    <updated>2021-04-05T14:52:36.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单实例"><a href="#单实例" class="headerlink" title="单实例"></a>单实例</h1><p><code>setnx</code> 是 <code>Redis</code> 官方提供的一个分布式原子性锁，它的实现利用了 <code>Redis</code> 在执行命令的时候是一个原子性操作，所以可以实现同一时间只有任务才能获取到锁。</p><p>当在同一个 <code>redis</code> 实例中进行加锁的操作的时候，如果加锁成功则会返回<code>1</code>，如果加锁失败的话，则是直接返回 <code>0</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx 'redislock' 1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>如果此时另一个任务想进行加锁的话，则会返回<code>0</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx 'redislock' 1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>虽然这样设置就可以实现一个分布式锁，但是如果一个客户端进行了加锁操作，后续自己的系统异常导致进程挂掉了，此时就会导致没有任务来进行解锁，从而导致任意一个客户端都无法再次加锁。</p><h2 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h2><p>redis官方提供了一个命令来支持这个加锁和设置超时时间的原子性命令：</p><blockquote><p><code>SET key value [EX seconds] [PX milliseconds] [NX|XX]</code></p></blockquote><p>其中 <code>NX</code> 和 <code>XX</code> 的区别在于，<code>NX</code> 是只有当 <code>key</code> 不存在的时候才设置，而 <code>XX</code> 则是当 <code>key</code> 存在的时候才进行设置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 v1 EX 10 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>这个命令表示当 <code>k1</code> 不存在的时候，设置该 <code>key</code> ，并且将其超时时间设置为 <code>10s</code>。</p><p>这个时间是一般是由业务人员根据业务的特性来指定的，当加入了超时时间以后，如果该 <code>key</code> 在超时时间内没有被主动的调用 <code>del</code> 命令，等超时时间过了以后，该 <code>key</code> 会自动被删除。此时另外一个系统就可以对这个 <code>key</code> 加锁了。</p><p>这样设置以后虽然可以解决上面的锁无法释放的问题，但是却又有一个新的问题，就是锁被他人释放了，例如：</p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/redission%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/setnx_2.png" alt=""></p><p>这种情况对于业务来说，是绝对不可以接受的，因为对于A任务来讲，它虽然释放了锁，但是它释放的其实是B的锁，此时如果有一个C任务再来加锁，就可以加锁成功了，于是分布式锁就变成了B、C可能在同一时间都在执行一个任务。</p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>为了保证在只有自己加的锁才能被自己释放，此时每一个任务就需要自己的一个唯一标志，这个标志一定是要全局唯一的。当释放锁的时候，需要判断当前持有锁的ID是否是释放锁的任务ID，但是由于这是一个非原子性的操作，所以此时就需要通过 lua 脚本来执行。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>在这里以 lua 脚本为例，lua脚本可以同时传入多个参数，在一个脚本里面执行，这样就可以判断加锁的value是不是当前传入的value。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set k1 A EX 10 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>此时的操作是 <code>A</code> 对 <code>k1</code> 进行加锁，假设 <code>A</code> 是一个全局唯一的，此时 <code>A</code> 对 <code>k1</code> 进行了加锁，并且锁的超时时间是 <code>10s</code> 。</p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>由于在这里是以 value 来作为唯一标志的，当释放锁的时候需要把当前的 <code>任务ID</code> 作为 <code>value</code> 传入，然后在删除key的时候，通过以下 lua 脚本来释放锁。</p><h4 id="lua脚本："><a href="#lua脚本：" class="headerlink" title="lua脚本："></a>lua脚本：</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">'exists'</span>,KEYS[<span class="number">1</span>]) == <span class="number">1</span>) <span class="keyword">and</span> (ARGV[<span class="number">1</span>] == redis.call(<span class="string">'get'</span>,KEYS[<span class="number">1</span>])) <span class="keyword">then</span> </span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">'del'</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>首先加载 lua 脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; script <span class="built_in">load</span> <span class="string">"if (redis.call('exists',KEYS[1]) == 1) and (ARGV[1] == redis.call('get',KEYS[1])) then return redis.call('del',KEYS[1]) else return 0 end;"</span></span><br><span class="line"><span class="string">"51fd717f3d833a79f1a102483df7932d4b71cd69"</span></span><br></pre></td></tr></table></figure><p>此时可以看到返回了一个hash值，这个值就是代表这个函数，当然也可以不用 hash 函数，每次用 eval 函数执行这个文本即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; eval "if (redis.call('exists',KEYS[1]) == 1) and (ARGV[1] == redis.call('get',KEYS[1])) then return redis.call('del',KEYS[1]) else return 0 end;" 1 k1 B</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>此时可以看到以 B 尝试释放这个锁，但是返回的是0，并未释放成功，再次查看该锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">"A"</span><br></pre></td></tr></table></figure><p>可以看到 k1 还是被 A 锁持有，尝试以 A 来释放锁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EVALSHA '51fd717f3d833a79f1a102483df7932d4b71cd69' 1 k1 A</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>可以看到已经被释放了，所以这个可以解决锁被其它任务释放的问题，但是还是无法解决超时导致的锁释放的问题。</p><h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><p>要解决这个问题，需要对超时时间进行续约，即除非 <code>A服务</code> 自己挂掉了让锁自己超时释放掉，否则就必须让A自己释放掉它。</p><h4 id="redission"><a href="#redission" class="headerlink" title="redission"></a>redission</h4><p><code>Redission</code> 是一款基于 Java 的 redis 操作 API 库，它采用的是一个 <code>Watch dog</code>  模式来解决这个问题的，具体做法是后台开启一个线程，这个线程每隔一定的时间去检查该锁还有多久超时，然后给这个锁进行续租。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>上述 Redis 的分布式锁在单实例的情况下是可以完美运行的，但是一旦涉及到 <code>reids</code>集群，就会出现重复加锁的情况。假设在一个一主三从的redis架构中，</p><p>如果任务 A 对主节点进行加锁成功了，此时主节点突然挂掉了，但是在挂掉之前，其锁没有同步到从节点，此时从节点其中一个晋升为主节点，于是两个任务此时都加锁成功了。</p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/redission%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/cluster-lock.png" alt=""></p><p>可以看到此时Redis 出现了脑裂情况，在这个情况下，A 和 B 都加锁成功了，但是这也就违背了分布式锁最初的初衷了，于是 RedLock 就被人提出来了。</p><h2 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h2><p>该算法是用 <code>Redis CRC16</code> 算法，计算出所有的 <code>master</code> 节点，然后记一个初始化时间，随后对所有的 <code>master</code> 节点进行加锁，计算出加锁的耗时时间，如果加锁的耗时时间小于超时时间，则接下来就可以执行任务了，否则锁过期了，就必须再次尝试再次加锁。</p><ol><li>记初始化时间</li><li>对所有的master加锁</li><li>计算加锁的耗时</li><li>判断是否小于过期时间</li><li>执行任务</li></ol><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>虽说 <code>RedLock</code> 可以解决某一个 <code>Redis</code> 节点挂掉，导致任务重复执行，但是还是无法避免如下问题：</p><ol><li><p>锁超时</p><p>例如如果在第4步的时候，应用出现了阻塞，就会导致锁其实过期了，但是任务 A 在锁过期以后还是在执行。</p></li><li><p>极度依赖服务器的时间</p><p>如果对A、B、C三个服务器进行加锁，任务 A 已经对A、B、C加锁了，但是此时B、C的服务器时间有问题，导致锁被提前释放了，而此时任务B对B、C加锁了，由于一半以上的master的节点已经加锁成功了，所以此时 任务B 其实也加锁成功了。</p></li></ol><p>​      </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于 Redis 的分布式锁，需要了解其可能出现的问题，然后再来做一些决策，任何一个技术都不是完美的，需要根据业务类型来选择最适合的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单实例&quot;&gt;&lt;a href=&quot;#单实例&quot; class=&quot;headerlink&quot; title=&quot;单实例&quot;&gt;&lt;/a&gt;单实例&lt;/h1&gt;&lt;p&gt;&lt;code&gt;setnx&lt;/code&gt; 是 &lt;code&gt;Redis&lt;/code&gt; 官方提供的一个分布式原子性锁，它的实现利用了 &lt;co
      
    
    </summary>
    
      <category term="Redis" scheme="https://somersames.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://somersames.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>重温生产者和消费者模型</title>
    <link href="https://somersames.github.io/2020/07/26/%E9%87%8D%E6%B8%A9%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>https://somersames.github.io/2020/07/26/重温生产者和消费者模型/</id>
    <published>2020-07-26T15:01:54.000Z</published>
    <updated>2021-04-05T14:52:36.653Z</updated>
    
    <content type="html"><![CDATA[<p>生产者和消费者模型，主要解决的是数据的同步问题，生产者将数据放置一个存储区域，然后消费者过来取数据。这种模式类似于一个中间件，可以使得生产者不需要关心消费者什么时候来拿数据，同时在这种模式下，还可以控制两边的处理速率，避免数据的丢失。</p><p>下面以 Java 为例，来写一个生产者和消费者模型。</p><p>当队列满了的时候，生产者自己进行阻塞。而当消费者发现队列为空，则将自己阻塞。</p><p>所以要实现这个生产者消费者模型，首先必须有以下条件：</p><ol><li>生产者或者消费者必须支持可阻塞</li><li>在多线程的情况下，必须保证并发安全（即插入不能产生数据错误），取数据不可以重复取</li></ol><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>在<code>Java</code> 中，常用的阻塞队列有 <code>LinkedBlockingQueue</code> 或者 <code>ArrayBlockingQueue</code>，这两个阻塞队列的实现都是基于 <code>ReentrantLock</code> ，通过可重入锁来控制并发情况下的插入操作。</p><p>所以，如下便是在 Java 中的生产者和消费者模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadPoolExecutor product = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000</span>, TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadPoolExecutor consumer = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000</span>, TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LinkedBlockingQueue linkedBlockingQueue = <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt; <span class="number">5</span> ;i++)&#123;</span><br><span class="line">            product.submit(<span class="keyword">new</span> Producer(<span class="number">100</span>,linkedBlockingQueue,i));</span><br><span class="line">            consumer.submit(<span class="keyword">new</span> Consumer(linkedBlockingQueue));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    LinkedBlockingQueue linkedBlockingQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(LinkedBlockingQueue linkedBlockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.linkedBlockingQueue = linkedBlockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumerStart(linkedBlockingQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumerStart</span><span class="params">(LinkedBlockingQueue&lt;Integer&gt; queue)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"消费者-----"</span>+queue.take());</span><br><span class="line">            Random random = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">            Thread.currentThread().sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    LinkedBlockingQueue linkedBlockingQueue;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(<span class="keyword">int</span> total, LinkedBlockingQueue linkedBlockingQueue, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">        <span class="keyword">this</span>.linkedBlockingQueue = linkedBlockingQueue;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            productStart(linkedBlockingQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">productStart</span><span class="params">(LinkedBlockingQueue&lt;Integer&gt; queue)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(number + <span class="string">"生产者----"</span>+queue.size());</span><br><span class="line">            queue.put(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><p>如果考虑在 Java 中使用 <code>LinkedList</code> 来实现阻塞队列，那么第一点，需要实现入队和出队的原子性，因为 <code>LinkedList</code> 是基于双向链表来实现的，所以在这里必须保证其原子性的操作。</p><p>在<code>Java</code> 中如果要实现对于链表的原子性操作，首先是加锁，考虑到加锁和释放锁导致的性能开销，决定使用可重入锁</p><p>有两种锁，一个是 <code>synchronized</code>，一个则是 <code>ReentrantLock</code> </p><h3 id="锁的选型"><a href="#锁的选型" class="headerlink" title="锁的选型"></a>锁的选型</h3><p><code>synchronized</code> 的加锁逻辑依赖于 <code>JVM</code> ，同时也是支持可重入。并且<code>JDK1.6</code> 以后对其做了大量的优化，所以一般情况下可以直接用<code>synchronized</code>。</p><p> <code>ReentrantLock</code> 是 <code>Java</code> 语言自带的一种可重入锁，相较于  <code>synchronized</code> ，它含有公平锁和非公平锁两种模式，并且支持  <code>Condition</code>。</p><p>在这里由于<code>LinkedBlockingQueue</code>采用的 <code>ReentrantLock</code> ，所以在这里也是采用 <code>ReentrantLock</code> </p><h3 id="阻塞以及唤醒"><a href="#阻塞以及唤醒" class="headerlink" title="阻塞以及唤醒"></a>阻塞以及唤醒</h3><p>当没有数据的时候，需要消费者阻塞，同时队列已经满了的情况下，需要生产者进行阻塞，而配合这些操作的就是将这些线程阻塞，在<code>java</code> 中可以通过 <code>wait</code> 和 <code>notify</code> 方法来进行阻塞和唤醒，</p><p>如果使用的是 <code>ReentrantLock</code>，也可以使用自己的 <code>Condition</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonBlockModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Condition produceCondition = reentrantLock.newCondition();</span><br><span class="line">    <span class="keyword">static</span> Condition consumerCondition = reentrantLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadPoolExecutor product = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000</span>, TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadPoolExecutor consumer = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,<span class="number">10</span>,<span class="number">1000</span>, TimeUnit.MICROSECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total =<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt; <span class="number">5</span> ;i++)&#123;</span><br><span class="line">            product.submit(<span class="keyword">new</span> NonBlockProducer(reentrantLock,linkedList,i,produceCondition,consumerCondition));</span><br><span class="line">            consumer.submit(<span class="keyword">new</span> NonBlockConsumer(reentrantLock,linkedList,produceCondition,consumerCondition));</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlockProducer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    ReentrantLock produceReentrantLock;</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedList;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    Condition produceCondition;</span><br><span class="line">    Condition consumerCondition;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonBlockProducer</span><span class="params">(ReentrantLock produceReentrantLock, LinkedList&lt;Integer&gt; linkedList, <span class="keyword">int</span> number, Condition produceCondition, Condition consumerCondition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.produceReentrantLock = produceReentrantLock;</span><br><span class="line">        <span class="keyword">this</span>.linkedList = linkedList;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.produceCondition = produceCondition;</span><br><span class="line">        <span class="keyword">this</span>.consumerCondition = consumerCondition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            produceReentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">10</span> == linkedList.size()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"队列已满，生产者被阻塞"</span> + number + <span class="string">"--"</span> + Thread.currentThread().getName());</span><br><span class="line">                    produceCondition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(linkedList.size() +<span class="number">1</span> &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                    linkedList.push(number);</span><br><span class="line">                    System.out.println(<span class="string">"添加元素"</span> + linkedList.size());</span><br><span class="line">                &#125;</span><br><span class="line">                consumerCondition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                produceReentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlockConsumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    ReentrantLock consumerReentrantLock;</span><br><span class="line">    LinkedList&lt;Integer&gt; linkedList;</span><br><span class="line">    Condition produceCondition;</span><br><span class="line">    Condition consumerCondition;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonBlockConsumer</span><span class="params">(ReentrantLock consumerReentrantLock, LinkedList&lt;Integer&gt; linkedList, Condition produceCondition, Condition consumerCondition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.consumerReentrantLock = consumerReentrantLock;</span><br><span class="line">        <span class="keyword">this</span>.linkedList = linkedList;</span><br><span class="line">        <span class="keyword">this</span>.produceCondition = produceCondition;</span><br><span class="line">        <span class="keyword">this</span>.consumerCondition = consumerCondition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            consumerReentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == linkedList.size()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"队列已空，消费者已阻塞"</span> + Thread.currentThread().getName());</span><br><span class="line">                    consumerCondition.await();</span><br><span class="line">                &#125;</span><br><span class="line">                linkedList.pollLast();</span><br><span class="line">                System.out.println(<span class="string">"移除元素"</span> + linkedList.size());</span><br><span class="line">                <span class="keyword">if</span>(linkedList.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    consumerCondition.signal();</span><br><span class="line">                &#125;</span><br><span class="line">                produceCondition.signal();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                consumerReentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;生产者和消费者模型，主要解决的是数据的同步问题，生产者将数据放置一个存储区域，然后消费者过来取数据。这种模式类似于一个中间件，可以使得生产者不需要关心消费者什么时候来拿数据，同时在这种模式下，还可以控制两边的处理速率，避免数据的丢失。&lt;/p&gt;
&lt;p&gt;下面以 Java 为例，
      
    
    </summary>
    
      <category term="并发" scheme="https://somersames.github.io/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://somersames.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>快速写一个程序将JVM的堆或者栈打满</title>
    <link href="https://somersames.github.io/2020/07/11/%E5%BF%AB%E9%80%9F%E5%86%99%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%B0%86JVM%E7%9A%84%E5%A0%86%E6%88%96%E8%80%85%E6%A0%88%E6%89%93%E6%BB%A1/"/>
    <id>https://somersames.github.io/2020/07/11/快速写一个程序将JVM的堆或者栈打满/</id>
    <published>2020-07-11T08:03:11.000Z</published>
    <updated>2021-04-05T14:52:36.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先「堆」或者「栈」在本质上其实是一个数据结构，简介如下：<br>「栈」既可以用链表来实现，又可以用数组来实现，用链表来实现的话，它是一个含有头指针和尾指针的一种数据结构，根据含有指针的不同，分为单链表和双向链表。<br>「堆」是一种类似于「完全二叉树」的数据结构</p><h2 id="JVM中的堆和栈"><a href="#JVM中的堆和栈" class="headerlink" title="JVM中的堆和栈"></a>JVM中的堆和栈</h2><p>在 JVM 中由于编译后的 class 文件都是一行行的指令，因此天然适合用「栈」这种数据结构，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译后如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"JvmTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JvmTest</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: iconst_0</span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">       <span class="number">5</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">8</span>: iload_1</span><br><span class="line">       <span class="number">9</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么对于这种指令来讲，以一种先进先出的方式存入肯定是最好的，所以在 JVM 中，栈的组成是一个一个的栈帧，那么每一个栈帧都包含如下几个部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">局部变量表</span><br><span class="line">操作数栈</span><br><span class="line">动态链接</span><br><span class="line">方法出口</span><br></pre></td></tr></table></figure></p><p>以 <code>HotSpot VM</code> 为例，由于其采用了固定栈大小的实现，也就指定了每一个线程的所能分配的栈内存的大小，那么依据此思路，可以有如下两种方法造成栈溢出：</p><ol><li>无限递归，导致无法为该线程分配内存</li><li>无限创建线程，导致无法为该线程分配足够的内存</li></ol><blockquote><p><code>-Xss</code> 可以指定栈的大小</p></blockquote><h3 id="demo1"><a href="#demo1" class="headerlink" title="demo1:"></a>demo1:</h3><p>注意加上启动参数：<code>-Xss16m</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverFlowTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> StackOverFlowTest().over(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">over</span><span class="params">(<span class="keyword">int</span> deepth)</span></span>&#123;</span><br><span class="line">        System.out.println(deepth);</span><br><span class="line">        over(++deepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不一会就可以看到 <code>java.lang.StackOverflowError</code></p><h3 id="demo2"><a href="#demo2" class="headerlink" title="demo2:"></a>demo2:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverFlowTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> StackOverFlowTest().threadOver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadOver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(threadTest).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.depth = depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> depth;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"thread start"</span> + depth);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>艹，运行到一半的时候，把 mac 搞挂了。<br>正常情况下是会出现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Unable to create <span class="keyword">new</span> <span class="keyword">native</span> thread</span><br></pre></td></tr></table></figure></p><h2 id="打满堆："><a href="#打满堆：" class="headerlink" title="打满堆："></a>打满堆：</h2><p>在 <code>JVM8</code> 中，堆一般存放的是 <code>对象实例</code>，含有 <code>S0</code>、<code>S1</code>、<code>Eden</code>、<code>Old</code>这几个区域，具体的可以查看 JVM 规范。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -Xmx32m</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;VM&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            VM vm = <span class="keyword">new</span> VM();</span><br><span class="line">            list.add(vm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VM</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[][] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行一段时间就会出现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at jvm.over_test.JvmTest$VM.&lt;init&gt;(JvmTest.java:<span class="number">30</span>)</span><br><span class="line">at jvm.over_test.JvmTest.main(JvmTest.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure></p><h2 id="元数据区："><a href="#元数据区：" class="headerlink" title="元数据区："></a>元数据区：</h2><p>首先 <code>元数据区</code> 保存的是 <strong>类信息、运行时常量池、以及即时编译器编译后的代码</strong> 等。那么根据存储的数据的特性，直接选择动态生成代理类的加载类信息来打满这个区域，需要注意的是这个区域使用的是机器的内存，所以在测试的时候最好指定下 <code>元数据区</code> 的大小。</p><blockquote><p>在这里也可以用自定的 <code>ClassLoader</code>，但是自定义 <code>ClassLoader</code> 需要重写 <code>loadClass</code> 方法，比较麻烦，所以直接选择使用代理类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -XX:MaxMetaspaceSize=16M -XX:MetaspaceSize=16M </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException</span>&#123;</span><br><span class="line">        List&lt;InterfaceA&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String classFilePath = <span class="string">"file:/Users/sunzhaohui/Desktop/person/java/MyCsNote/jvm/src/main/java/jvm/StringTest"</span>;</span><br><span class="line">        URL[] classFileUrl = <span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(classFilePath)&#125;;</span><br><span class="line">        URLClassLoader newClassLoader = <span class="keyword">new</span> URLClassLoader(classFileUrl);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            InterfaceA t = (InterfaceA) Proxy.newProxyInstance(newClassLoader, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;InterfaceA.class&#125;, <span class="keyword">new</span> MyInvocationHandler(<span class="keyword">new</span> InterfaceAImpl()));</span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆和栈&quot;&gt;&lt;a href=&quot;#堆和栈&quot; class=&quot;headerlink&quot; title=&quot;堆和栈&quot;&gt;&lt;/a&gt;堆和栈&lt;/h1&gt;&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结
      
    
    </summary>
    
      <category term="JVM" scheme="https://somersames.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://somersames.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Thread.sleep(0)-vs-Thread.yield()</title>
    <link href="https://somersames.github.io/2020/07/07/Thread-sleep-0-vs-Thread-yield/"/>
    <id>https://somersames.github.io/2020/07/07/Thread-sleep-0-vs-Thread-yield/</id>
    <published>2020-07-06T16:25:44.000Z</published>
    <updated>2021-04-05T14:52:36.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Thread.sleep(long)</code> 和 <code>yield()</code> 都表示的是让出当前线程的 <code>CPU</code> 时间片，两者在执行的时候，都不会去释放自己已经持有的锁。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>在现代的处理器中，以 <code>4核心CPU</code> 为例，这表示在同一个时刻，只会有 4 个线程在并行执行，而在每一个核心内部，多个线程其实是顺序执行的，它们的执行顺序依赖于线程的调度算法。</p><h3 id="线程调度算法"><a href="#线程调度算法" class="headerlink" title="线程调度算法"></a>线程调度算法</h3><p>目前主要的调度算法有如下几种「可能不全」：</p><ol><li>先进先出（FIFO）</li><li>最短耗时优先算法（SJF）</li><li>时间片轮转算法（RR）</li><li>优先级排序调度算法（PS）</li><li>多级反馈队列算法（MLFQ）</li></ol><p>以 <code>时间片轮转算法</code> 为例，多个线程每一个线程都会分到一定的执行时间，当本次执行时间结束以后，就会发生上下文切换。<br>同理，对于其他的调度算法，其实本质上都是一致的，就是在同一个时刻，一个核心只能执行一个线程，多线程其实就是通过CPU核心轮流执行线程。</p><p>在多线程编程中，如果需要暂停当前线程的执行，可以调用<code>Thread.sleep(long millis)</code> 方法，来让出<code>CPU</code> 时间片，即表示在接下来的 <code>millis</code> 毫秒内，该线程不再参与 <code>CPU</code> 时间片的竞争。</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>在 Java 中，可以通过执行 <code>jstack pid</code> 命令来查看线程的运行状态，如下图所示：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/ThreadSleep/ThreadStatus_1.png" alt=""><br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/ThreadSleep/ThreadStatus_2.png" alt=""></p><p>从上面两张图可以看到，目前在 Java 中，是已经含有四种状态了，那么还有两种没有列出来，它们分别是 <code>NEW</code>，<code>TERMINATED</code></p><ul><li><code>NEW</code>：这个状态表示的是线程刚刚创建，例如 <code>new Thread()</code>;</li><li><code>RUNNABLE</code>：其实这个状态，在 <code>Java</code> 中表示的是 <code>就绪</code> 和 <code>运行</code><ul><li><code>就绪</code> ：代表这个线程可以执行了，但是还在等待 <code>CPU</code> 的调度</li><li><code>运行</code> ：代表这个线程已经在执行中了</li></ul></li><li><code>WAITING</code>：表示该线程正在等待一些条件，常见于调用了<code>Object.wait</code>,<code>Thread.join</code>,<code>LockSupport.park</code></li><li><code>TIMED_WAITING</code>：对于线程的这种状态，常见于调用了 <code>Thread.sleep(long)</code> 或者 <code>Object.wait(long)</code> 方法等</li><li><code>BLOCKED</code>：常见于互斥锁的竞争</li><li><code>TERMINATED</code>：线程终止</li></ul><h2 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h2><p>那么当一个线程调用了 <code>Sleep</code> 方法之后，会由 <code>RUNNABLE</code> 转为 <code>TIMED_WAITING</code>，这个表示在接下来的 <code>long</code> 毫秒内，该线程不再参与 <code>CPU</code> 资源的竞争，需要注意的是 <code>sleep</code> 方法不会释放所持有的锁。</p><h3 id="Sleep-0"><a href="#Sleep-0" class="headerlink" title="Sleep(0)"></a>Sleep(0)</h3><p>那么当调用 <code>Sleep(0)</code> 的时候，究竟会发生什么，查看下 <code>Java</code> 的源代码，发现是一个 <code>native</code> 方法，于是查看 <code>hotspot</code> 方法，其代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Sleep"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), <span class="string">"timeout value is negative"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Thread::is_interrupted (THREAD, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">    THROW_MSG(vmSymbols::java_lang_InterruptedException(), <span class="string">"sleep interrupted"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save current thread state and restore it at the end of this block.</span></span><br><span class="line">  <span class="comment">// And set new thread state to SLEEPING.</span></span><br><span class="line">  <span class="function">JavaThreadSleepState <span class="title">jtss</span><span class="params">(thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USDT2</span></span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__sleep__begin, millis);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  HOTSPOT_THREAD_SLEEP_BEGIN(</span><br><span class="line">                             millis);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line"></span><br><span class="line">  EventThreadSleep event;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// When ConvertSleepToYield is on, this matches the classic VM implementation of</span></span><br><span class="line">    <span class="comment">// JVM_Sleep. Critical for similar threading behaviour (Win32)</span></span><br><span class="line">    <span class="comment">// It appears that in certain GUI contexts, it may be beneficial to do a short sleep</span></span><br><span class="line">    <span class="comment">// for SOLARIS</span></span><br><span class="line">    <span class="keyword">if</span> (ConvertSleepToYield) &#123;</span><br><span class="line">      os::yield();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ThreadState old_state = thread-&gt;osthread()-&gt;get_state();</span><br><span class="line">      thread-&gt;osthread()-&gt;set_state(SLEEPING);</span><br><span class="line">      os::sleep(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">      thread-&gt;osthread()-&gt;set_state(old_state);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 忽略其他代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USDT2</span></span><br><span class="line">  HS_DTRACE_PROBE1(hotspot, thread__sleep__end,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  HOTSPOT_THREAD_SLEEP_END(</span><br><span class="line">                           <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></p><p>从这段代码可以看到，在 <code>JVM</code> 中有一个选项，叫做 <code>ConvertSleepToYield</code>，这个参数默认是为 <code>true</code> 的，所以当调用 <code>Sleep(0)</code> 的时候，默认的会调用 <code>Thread.yield()</code> 方法。</p><p>那么如果关闭了这个选项的话，会调用 <code>os::sleep(thread, MinSleepInterval, false);</code> ,而 <code>MinSleepInterval</code> 的值是 <code>1</code>，所以如果关闭了这个选项的话，那么 JVM 首先会将当前的线程状态赋值为 <code>old_state</code>，然后通过 <code>os::sleep</code> 让其休眠 <code>1ms</code>，然后在将线程设置成原来的状态。</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>其实对于 <code>yield</code> 方法，jvm 也可以将其转换为 Sleep 方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Yield(JNIEnv *env, jclass threadClass))</span><br><span class="line">  JVMWrapper(<span class="string">"JVM_Yield"</span>);</span><br><span class="line">  <span class="keyword">if</span> (os::dont_yield()) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USDT2</span></span><br><span class="line">  HS_DTRACE_PROBE0(hotspot, thread__yield);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  HOTSPOT_THREAD_YIELD();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  <span class="comment">// When ConvertYieldToSleep is off (default), this matches the classic VM use of yield.</span></span><br><span class="line">  <span class="comment">// Critical for similar threading behaviour</span></span><br><span class="line">  <span class="keyword">if</span> (ConvertYieldToSleep) &#123;</span><br><span class="line">    os::sleep(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    os::yield();</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure></p><p>在 JVM 中，<code>ConvertYieldToSleep</code> 默认值是 <code>false</code>，所以如果不更改 JVM 的默认配置的话，<code>yield</code> 方法会调用 <code>os::yield();</code> 方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实对于 <code>Thread.sleep(0)</code> 和 <code>yield</code> 方法来讲，如果仅仅使用的是默认配置的话，那么它们最终调用的都是 <code>OS</code> 的 <code>yield</code> 方法。</p><p>那么其实对于它们来说，在执行的时候，都是让 <code>CPU</code> 再次发一个调度，如果当前的线程，没有被选中执行，那么它的状态就会由 <code>RUNNABLE</code> 变成 <code>WAITING</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Thread.sleep(long)&lt;/code&gt; 和 &lt;code&gt;yield()&lt;/code&gt; 都表示的是让出当前线程的 &lt;c
      
    
    </summary>
    
      <category term="Java" scheme="https://somersames.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://somersames.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocalMap 简单分析</title>
    <link href="https://somersames.github.io/2020/07/02/ThreadLocalMap-simple-analysis/"/>
    <id>https://somersames.github.io/2020/07/02/ThreadLocalMap-simple-analysis/</id>
    <published>2020-07-01T16:05:58.000Z</published>
    <updated>2021-04-05T14:52:36.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>在使用多线程的时候，如果需要保存一份线程自己私有的一部分变量，避免其他线程污染这个变量的话，一般都会自己手动 new 一个 ThreadLocal，如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">threadLocal.set(<span class="string">"test"</span>);</span><br></pre></td></tr></table></figure></p><p>当需要在某一刻使用这个变量的时候，只需要手动调用下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">threadLocal.get();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">## ThreadLocalMap</span><br><span class="line">ThreadLocalMap 是 ThreadLocal 的一个静态内部类，每一个线程在创建的时候都会有这个 ThreadLocalMap 变量，它的作用就是存储每一个通过 `threadLocal.set()` 方法存入的值，本质上也是一个HashMap。</span><br><span class="line"></span><br><span class="line">先看下它的一个内部类：</span><br><span class="line">### Entry</span><br><span class="line">不同于 WeakHashMap 是继承自 HashMap 的Entry，ThreadLocalMap 的Entry 则是自己的一个内部类。</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里可以看到的是，ThreadLocalMap.Entry 是以 <code>ThreadLocal&lt;?&gt;</code> 为 key 的，也就是 ThreadLocalMap 它的整体设计如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/ThreadLocalMap/ThreadLocalMap.png" alt=""></p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><code>table</code>：表示的是一个 <code>Entry</code> 数组<br><code>threshold</code>：下一次扩容的临界值，算法为 数组的长度的 2/3<br><code>INITIAL_CAPACITY</code>：数组的大小，默认是 16</p><h4 id="Entry扩容"><a href="#Entry扩容" class="headerlink" title="Entry扩容"></a>Entry扩容</h4><p><code>table</code> 的扩容是直接新建了一个 <code>Entry[]</code> 数组，将其长度设置为旧数组长度的 2 倍，然后通过一个 <code>for</code> 循环，将元素都重新移至新的 <code>table</code> 上，但是在移植的过程中，如果发现了 <code>Entry</code> 中的 Key 为空的话，那么就会直接将其 value 设置为 null 来帮助GC，避免内存的泄漏。</p><blockquote><p>如果在移植的过程中发生了 Hash 碰撞，那么会直接将当前下标 + 1，然后判断该位置是否有元素，如果有的话，继续 + 1，直至没有元素。</p></blockquote><h3 id="新增过程"><a href="#新增过程" class="headerlink" title="新增过程"></a>新增过程</h3><p>当调用 <code>threadLocal.set()</code> 方法的时候，会首先判断 <code>ThreadLocalMap</code> 存不存在。从而进入不同的处理流程上来。</p><h4 id="ThreadLocalMap-不存在"><a href="#ThreadLocalMap-不存在" class="headerlink" title="ThreadLocalMap 不存在"></a>ThreadLocalMap 不存在</h4><p>如果不存在的话，就会调用 <code>createMap</code> 方法来进行初始化。<br>而 <code>createMap</code> 直接就是通过默认值来初始化一个 <code>ThreadLocalMap</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="ThreadLocalMap-存在"><a href="#ThreadLocalMap-存在" class="headerlink" title="ThreadLocalMap 存在"></a>ThreadLocalMap 存在</h4><p>如果存在的话，这时直接以当前的 <code>ThreadLocal</code> 为 <code>Key</code>，通过 <code>Hash算法</code> 算出该对象在 <code>table</code> 中的下标，然后判断该下标是否有值(Entry是否为null)，如果有值的话，则判断 <code>Entry</code> 中的 <code>key</code> 是否与当前的 <code>ThreadLocal</code> 相等（地址比较），如果相等的话，则直接将 <code>value</code> 赋值，然后 return。</p><p>如果 <code>Entry</code> 中的 <code>key</code> 为 <code>null</code> 的话，则会执行 <code>replaceStaleEntry</code> 方法来找 <code>key</code>，同时在这个方法内部，还会通过 <code>渐进式或者启发式</code> 的方式来进行清除旧key操作。<br>先大致列出其 set 的过程：</p><p><strong>1.</strong> 获取该 key 的 <code>threadLocalHashCode</code>，然后与当前 <code>table(Entry[]的长度) -1</code> 进行 <code>&amp;</code> 运算，计算出下标。</p><h5 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h5><p><code>ThreadLocalMap</code> 的 <code>Hash算法</code> 采用的是 <code>斐波那契散列</code>，其过程是用 <code>0x61c88647</code> 累加，然后用累加的结果与当前 <code>table(Entry[]的长度) - 1</code> 进行 <code>&amp;</code> 运算。</p><blockquote><p><code>0x61c88647</code> 转化为十进制是 <code>1640531527</code>，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在这里的 <code>nextHashCode</code> 是一个 <code>AtomicInteger</code>，因此可以保证其原子性，而且又是私有的静态变量，所以可以尽量保证每一个 <code>ThreadLocal</code> 都会得到一个唯一的 <code>HashCode</code>。</p><p><strong>2.</strong> 找出 <code>table[i]</code> 中不为 <code>null</code> 的 <code>Entry</code>，在这个过程中会一直 <code>i+1</code>，如果 <code>i+1</code> 大于数组的最大下标的话，则直接从 0 开始寻找。</p><p><strong>3.</strong> 当在遍历的过程中，如果发现 <code>Entry 的 key</code> 与当前的 <code>ThreadLocal</code> 对象相等的话，则直接将值替换，如果发现某一个 <code>Entry</code> 的 <code>key</code> 为 null 的话，则直接进行 <code>replaceStaleEntry</code>。然后return。</p><h5 id="replaceStaleEntry方法"><a href="#replaceStaleEntry方法" class="headerlink" title="replaceStaleEntry方法"></a>replaceStaleEntry方法</h5><p>该方法出现在 <code>set方法</code> 的第三步，即当判断到 <code>Entry</code> 中的 key 为 <code>null</code>，那么此时就会调用 <code>replaceStaleEntry</code> 来清除那些被回收了的 <code>Key</code>。在这个方法里面，每一个遍历都会将 <code>staleSlot</code> 赋值到 <code>i</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先将 `staleSlot` 赋值为 `i` ，通过 `i` 向前遍历，直至遍历到第一个 `Entry` 为 null，如果在遍历的过程中发现某些 `Entry` 的 `key` 为 null 的话，则将 i 赋值到 `slotToExpunge`。如果说遍历了完整的一圈没发现 key 为 null 的 Entry 的话，那么一定会在 `staleSlot` 这个地方停下来，因为进入这个方法的前提就是 `key == null`。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随后再沿着传入的 `index` 的向后进行遍历，如果此时在遍历的过程中出现了 `Hash冲突`，则直接 `value` 赋值到当前 `Entry` 的 `value` 中。同时判断在第一个遍历中的 `slotToExpunge` 是不是 `staleSlot`，如果是的话，则直接当前的 `index` 设置为`slotToExpunge`，然后调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为在 set 方法的遍历中，肯定不会出现 k == key，所以此时可以判断下，如果有的话，则直接赋值，然后就可以return 了。</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"><span class="comment">//第一个循环中，没有出现 key 为null 的 Entry，则直接将 slotToExpunge 赋值为 i，</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line"><span class="comment">//expungeStaleEntry 方法会进行 rehash，直至往后遍历到第一个为 null 的 Entry停止，在此期间也会进行rehash，同时在此期间，如果遇到了 key 为 null 的 Entry，会将他们的 Entry 以及 value 都置为 null，便于 GC。</span></span><br><span class="line"><span class="comment">//cleanSomeSlots 方法会以 log2(len) 的循环次数进行清除旧的 Entry，如果发现 Key 为 null 的 Entry，就会再次调用expungeStaleEntry 方法继续清理旧Key</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//如果在遍历的途中，没发现 k == key，那么此时如果在向前的遍历中，也没有发现 Key 为 null 的，此时就会将slotToExpunge 设置为 i。</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"><span class="comment">//如果说之前发现 key 为null 的话，那么此时slotToExpunge 肯定就不会等于 staleSlot，于是触发清除旧Key的方法。</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>4.</strong> 在第三步的时候，直接找到了为 <code>null</code> 的<code>Entry</code>，则直接新建一个 <code>Entry</code> 然后赋值，<br><strong>5.</strong> 当上述步骤都处理完了以后，会通过 <code>cleanSomeSlots</code> 进行判断，如果有 <code>Entry</code> 的弱引用是否被回收了，则会进行 <code>rehash</code>，除非数组的长度已经达到了 <code>threshold</code> 并且未发现 <code>Entry</code> 的弱引用被回收了，才会进行 rehash。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"><span class="keyword">int</span> sz = ++size;</span><br><span class="line"><span class="comment">// 在这里需要注意的是只有没发生弱引用的清除才会进行Rehash，因为一旦出现了清除，则会在 expungeStaleEntry 做 rehash，所以此时就不必在做一次了。</span></span><br><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure></p><h3 id="set方法流程图"><a href="#set方法流程图" class="headerlink" title="set方法流程图"></a>set方法流程图</h3><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/ThreadLocalMap/set.png" alt=""></p><h4 id="expungeStaleEntry-int-staleSlot-方法"><a href="#expungeStaleEntry-int-staleSlot-方法" class="headerlink" title="expungeStaleEntry(int staleSlot)方法"></a>expungeStaleEntry(int staleSlot)方法</h4><p>该方法是 <code>ThreadLocal</code> 主要用于清除旧 Key，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"> <span class="comment">//当前的Entry的key是null，则直接将value和Entry一起全部设置为 null，帮助GC</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 重新Rehash，不过rehash的范围是 staleSlot 到下一个为 null 的 Entry</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在这里之所以是要进行重新 <code>hash</code>，是因为一旦出现某一个 <code>Key</code> 被回收以后，会导致后面的 <code>Key</code> 无法正确的 <code>hash</code> 到数组的正确下标下，从而导致每一次的 <code>get</code> 操作都会进行一次遍历，时间复杂度由 <code>O(1)</code> 直接退化为 <code>O(n)</code></p></blockquote><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/ThreadLocalMap/rehash.png" alt=""></p><h3 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h3><p><code>ThreadLocal</code> 的 <code>get</code> 方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里需要注意的一个方法是 <code>getEntry</code> ,如果在调用的时候，发生了 <code>Hash冲突</code>，那么该方法会调用<code>getEntryAfterMiss</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里可以发现，其实最终还是调用的 <code>expungeStaleEntry</code>，而该方法在之前已经说过了，所以 <code>ThreadLocal</code> 在 <code>get</code> 的时候，其实还会旧的 <code>key</code> 的清除。直至遍历到第一个 <code>e == null</code> 的对象，此时则表示该 <code>key</code> 不存在，于是直接返回 <code>null</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，<code>ThreadLocal</code> 在 <code>set</code> 的过程中，首先会进行 <code>Hash</code> 找出下标，如果该下标的 <code>Entry</code> 为 <code>null</code> 的话，则直接赋值，如果不为 <code>null</code> 的话，则会进行遍历，直至找出第一个不为 <code>null</code> 的 <code>Entry</code> 然后赋值。</p><p>如果在遍历的过程中，发现了某些  <code>Entry</code> 的 <code>Key</code> 为 <code>null</code> 的话，则代表可以通过清理旧的 <code>Entry</code> 来进行赋值操作，那么其过程是，首先获取到在遍历过程中 <code>Entry</code> 的 <code>Key</code> 为 <code>null</code> 的下标，记为 <code>staleSlot</code>，然后向前遍历，直至第一个 <code>Entry</code> 为 <code>null</code> 止，然后记录在遍历的过程中，最后一个 <code>Entry</code> 的 <code>Key</code> 为 <code>null</code> 的下标。<br>随后进行第二次的遍历，如果在往后的遍历过程中，出现了 <code>Entry</code> 的 <code>key</code> 与当前的 <code>key</code> 相等的话，则直接赋值。</p><p>然后判断如果在之前的第一个遍历中，所有的 <code>Entry</code> 的 <code>key</code> 都不为 <code>null</code> ，那么此时直接将当前下标赋值为 <code>旧Key</code> 清除的起点，随后先进行一个<code>渐进式清理expungeStaleEntry</code>，等这一步清理完毕以后，再进行一次<code>启发式清理cleanSomeSlots</code>，<code>cleanSomeSlots</code>会进行一次 <code>log2(n)</code> 次清理，以<code>渐进式清理expungeStaleEntry</code> 后的 <code>index</code> 为起点，在之后的 <code>log2(n)</code> 下标内，如果还是出现了 <code>key</code> 为 <code>null</code> 的 <code>Entry</code>，则还是会再进行 <code>渐进式清理expungeStaleEntry</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h2&gt;&lt;p&gt;在使用多线程的时候，如果需要保存一份线程自己私有的一部分变量，避免其
      
    
    </summary>
    
      <category term="Java" scheme="https://somersames.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://somersames.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>mysql中count(*)和count(1)的区别</title>
    <link href="https://somersames.github.io/2020/06/05/the-difference-between-count-and-count-1/"/>
    <id>https://somersames.github.io/2020/06/05/the-difference-between-count-and-count-1/</id>
    <published>2020-06-04T16:01:47.000Z</published>
    <updated>2021-04-05T14:52:36.616Z</updated>
    
    <content type="html"><![CDATA[<p>在进行旧的项目 review 的时候，我发现绝大多数的统计SQL都是基于 <code>count(1)</code> 来进行的，只有一少部分是基于 <code>count(*)</code>，那么这两种写法到底有什么区别。</p><p>mysql中，常用的存储引擎有<code>myisam</code>和<code>innodb</code>，但是由于<code>myisam</code>只支持表级别锁，而且还不支持事物，所以在mysql的5.5版本之后就将默认的存储引擎调整为<code>innodb</code>。</p><p>&nbsp;<br>以下实验基于 <code>Mysql8.0.1</code> 来进行<br>&nbsp; </p><p>首先这里准备了一个表.<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/full_columns.png" alt=""></p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/mysql-showtable.png" alt=""></p><p>在此之前先通过 <code>show table status</code> 查看表中的数据，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from t_book;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|    54173 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到此时查询出来的<code>ROWS</code>是<code>53935</code>，那么再查看下通过索引查询出来的数据行数有多少呢？ 可以看到<code>show index from t_book</code> 查询出来的数据如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/show_index.png" alt=""></p><p>其中有大概 238 条数据的统计差异，这其实是因为Mysql的<code>show table status</code>查询出来的只是一个估计值。</p><h3 id="查看系统的show-table-status"><a href="#查看系统的show-table-status" class="headerlink" title="查看系统的show table status"></a>查看系统的<code>show table status</code></h3><p>在mysql的系统库中可以看到 <code>t_book</code> 表的相关信息，可以使用如下方式：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/mysql_status.png" alt=""><br>其中的<code>n_rows</code>就是之前查询出来的值，但是这一个值是一个粗略估计的值。<br>而 <code>clustered_index_size</code> 和 <code>sum_of_other_index_sizes</code> 则分别表示的是聚簇索引和其它的索引所占有的页的数量</p><blockquote><p>回到之前的主题上来，那么下面就来看下 <code>count(*)和count(1)</code> 的区别：</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>首先打开 Mysql 的 <code>warnings</code>，便于分析日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; warnings;</span><br><span class="line">Show warnings enabled.</span><br></pre></td></tr></table></figure></p><p>然后再分析下两个之前的差异：</p><h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/count%2A.png" alt=""><br>可以看到此时 <code>count*</code> 走的是一个二级索引，但是在 Note 里面可以看到最后 <code>count(*)</code> 还是被转换成了<code>count(0)</code>。  </p><h4 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h4><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/count1.png" alt=""><br>而 <code>count(1)</code> 可以发现也是走的一个二级索引</p><h3 id="索引的选择"><a href="#索引的选择" class="headerlink" title="索引的选择"></a>索引的选择</h3><p>在 <code>Mysql</code> 中，由于主键索引一般情况下是比二级索引大的，所以在Mysql中，如果有二级索引的话，那么Mysql一定会选择一个二级索引来作为 <code>count</code> 的字段。</p><p>但是当有多个二级索引的时候，Mysql又会如何选择索引呢？</p><p>首先以 <code>book_page</code> 为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index book_page on t_book(book_page);</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure></p><p>然后通过 <code>count</code> 函数查询如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/mysql_count_num.png" alt=""></p><blockquote><p>由于 count(1) 执行结果与这个类似，就不放截图了</p></blockquote><p>这个时候可以看到 <code>book_page</code> 的索引 <strong>key_len</strong> 是5，那么如果第二个 <code>二级索引</code> 的 key_len 比这个短的话，那么 Mysql 会该如何选择呢？ </p><h4 id="以-book-num-作为索引"><a href="#以-book-num-作为索引" class="headerlink" title="以 book_num 作为索引"></a>以 book_num 作为索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index book_num on t_book(book_num);</span><br><span class="line">Query OK, 0 rows affected (0.12 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p>此时查看 <code>count(*)</code>和 <code>count(1)</code>，可以发现 <code>Mysql</code> 选择的是 <code>book_num</code> 索引作为 count 的字段。</p><blockquote><p>对比之前的索引的 <code>key_len</code>，你会发现 <code>Mysql</code> 在有多个二级索引的情况下，是会优先选择 <code>key_len</code> 较小的索引。</p></blockquote><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/mysql_key_len4.png" alt=""></p><p><strong>由于<code>count(*)</code>和 <code>count(1)</code>索引的选择是一样的，此时就不放 <code>count(1)</code> 截图</strong> </p><blockquote><p>PS：为了验证索引的创建顺序对 Mysql count 的选择没有影响，因此在这之后，又测试了一遍，不过是先创建的 <code>book_num</code>，后创建的 <code>book_page</code>，此时发现 Mysql 还是选择 <code>book_num</code> 作为索引。</p></blockquote><h4 id="相同的Key-len"><a href="#相同的Key-len" class="headerlink" title="相同的Key_len"></a>相同的Key_len</h4><p>&nbsp;<br>如果此时两个二级索引的 <code>key_len</code> 相同，<code>Mysql</code> 又会怎样选择呢？<br>此时修改 <code>book_num</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE t_book MODIFY  book_num int(11) NULL;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.92 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 1</span><br></pre></td></tr></table></figure></p><p>此时进行 explain：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/mysql_ken_len5.png" alt=""></p><p>再反复的测试之后，会发现 Mysql 在 <code>相同的 key_len</code> 下，会自动的选择最后一个创建的 <code>最小 key_len</code> 索引最为 count 索引。</p><h4 id="索引的选择跟区分度有关系吗"><a href="#索引的选择跟区分度有关系吗" class="headerlink" title="索引的选择跟区分度有关系吗"></a>索引的选择跟区分度有关系吗</h4><p> &nbsp;<br>将 <code>book_page</code> 的字段区分度弄的低一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t_book set book_page = 10 limit 10000;</span><br><span class="line">Query OK, 9888 rows affected (0.10 sec)</span><br><span class="line">Rows matched: 10000  Changed: 9888  Warnings: 0</span><br></pre></td></tr></table></figure></p><p> &nbsp;<br>然后此时再查看 <code>Mysql</code> 是如何选择索引的。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/book_page_index.png" alt=""></p><p>此时还是选择的是 <code>book_page</code> 字段，如果再把 <code>book_num</code> 的区分度弄的更低呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t_book set book_num = 100 limit 30000;</span><br><span class="line">Query OK, 29970 rows affected (0.40 sec)</span><br><span class="line">Rows matched: 30000  Changed: 29970  Warnings: 0</span><br></pre></td></tr></table></figure></p><p>最后对比会发现，执行的还是 <code>book_page</code> 作为索引，那么这是为什么呢？</p><h3 id="optimizer-trace-分析"><a href="#optimizer-trace-分析" class="headerlink" title="optimizer_trace 分析"></a>optimizer_trace 分析</h3><p>首先打开<code>optimizer_trace</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET optimizer_trace=&quot;enabled=on&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>然后执行 <code>count(1)</code> 语句。最后查看结果如下：只截取关键信息：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/page_num_cost.png" alt=""></p><p>可以看到在使用 <code>book_page</code> 做索引的时候，Mysql认为其 cost 是 5808.1，那么对于 <code>book_num</code> 索引呢？</p><h3 id="book-num"><a href="#book-num" class="headerlink" title="book_num"></a>book_num</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from t_book force index(book_num);</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|    54173 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>执行完以后，查看 cost 如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/mysql-diff-count/book_num_cost.png" alt=""></p><p>可以看到他的 cost 是 59193，所以 <code>Mysql</code> 认为 <code>book_page</code> 更加划算，那么是不是因为 <code>book_num</code> 的区分度太低，导致 cost 变大了呢？，此时调整 <code>book_page</code> 字段的值，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update t_book set book_page =1 limit 53000;</span><br><span class="line">Query OK, 52548 rows affected (0.68 sec)</span><br><span class="line">Rows matched: 53000  Changed: 52548  Warnings: 0</span><br></pre></td></tr></table></figure></p><p>然后会发现，Mysql 还是会选择 <code>book_page</code> 作为索引来进行 count，于是后来测试了下创建索引的顺序，发现当 <code>key_len</code> 相同的时候，Mysql是会选择首次创建的索引来进行 <code>count</code>，除非有更小的 <code>key_len</code>  出现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以 <code>Mysql</code> 在选择 <code>count</code> 的时候，优先会选择 <code>二级索引</code>，当有多个 <code>二级索引</code> 的时候，会优先选择 <code>key_len</code> 小的，当有多个 <code>key_len</code> 相同的二级索引时，直接选择第一次创建该 <code>key_len</code> 的索引。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在进行旧的项目 review 的时候，我发现绝大多数的统计SQL都是基于 &lt;code&gt;count(1)&lt;/code&gt; 来进行的，只有一少部分是基于 &lt;code&gt;count(*)&lt;/code&gt;，那么这两种写法到底有什么区别。&lt;/p&gt;
&lt;p&gt;mysql中，常用的存储引擎有&lt;co
      
    
    </summary>
    
      <category term="Mysql" scheme="https://somersames.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://somersames.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Springboot自定义@EnableXX注解</title>
    <link href="https://somersames.github.io/2020/05/26/define-a-enable-anno-in-springboot/"/>
    <id>https://somersames.github.io/2020/05/26/define-a-enable-anno-in-springboot/</id>
    <published>2020-05-25T16:05:16.000Z</published>
    <updated>2021-04-05T14:52:36.592Z</updated>
    
    <content type="html"><![CDATA[<p>在SpringBoot中，经常可以看到许多以 <code>@Enable</code> 开头的注解，例如：<code>@EnableAutoConfiguration</code>，<code>@EnableAsync</code>……，那么我们是否可以自己定义一个注解呢？</p><p>其实自定义注解最终都是利用到了 <code>ImportBeanDefinitionRegistrar</code> 这个类，通过手动的方式，将一个类注册成为 <code>Bean</code>，然后在进行一系列的操作，下面就来看下 <code>ImportBeanDefinitionRegistrar</code></p><h2 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h2><p>这个类的代码如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/ImportBeanDefinitionRegistrar.png" alt=""></p><p>可以看到这个类的结构很简单，就是一个方法，那么下面来看下这两个参数是什么意思。</p><h3 id="AnnotationMetadata"><a href="#AnnotationMetadata" class="headerlink" title="AnnotationMetadata"></a>AnnotationMetadata</h3><p>从字面的意思上可以看出来是一个注解的元数据，它的里面的的方法如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/AnnotationMetadata.png" alt=""><br>都是一些获取注解信息的方法，那么第二个参数呢</p><h3 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h3><p>从字面的意思上可以看出来这个类是用于注册 <code>Bean</code> 的，其中最常见的就是 <code>registerBeanDefinition</code> 方法。它提供了两个参数 <code>String beanName, BeanDefinition beanDefinition</code>，而具体使用，则来看看demo。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>假设现在有一个需求是要写一个切面，这个切面负责打印<code>controller</code> 的log。但是可能某些系统有自己的日志格式，不太需要这个切面AOP，所以希望可以增加一个开关，然后是按需引用。<br>下面就来开始写一个这样的demo，项目结构如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/project-tree.png" alt=""></p><p>在这里为什么会初始化两个文件夹，是因为 <code>@SpringBootApplication</code> 这个注解会默认将当前目录以及它的下级目录下的 <code>Bean</code> 注入到容器中，所以新建一个同级目录<code>anno</code> 就是为了不让 <code>@SpringBootApplication</code> 加载切面。</p><p>然后启动 <code>Application</code> 这个类，其中 <code>RestControllerTest</code> 就是一个很简单的 <code>Controller</code>，如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/RestControllerTest.png" alt=""></p><p>然后请求<code>http://localhost:8081/api/query/1</code>，可以看到在控制台没有任何的输出，那就说明自定义的切面还没有生效，此时在 <code>Application</code> 上添加我们的自定义注解，添加后代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableLog</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时在此启动项目，你会发现已经已经在控制台有我们的日志log了。<br>实现的细节见下面几个类：</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="interface"><a href="#interface" class="headerlink" title="@interface"></a>@interface</h3><p>首先，我们需要定义一个注解，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;LogRegister.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里使用了 <code>@Import</code> 这个注解，由于不是本文的重点，因此不讲述其作用,（后面讲自动装配的原理时会讲解）然后这里有一个 <code>LogRegistrar</code> 类，这个类就是实现自定义注解的关键。</p><h3 id="LogRegister"><a href="#LogRegister" class="headerlink" title="LogRegister"></a>LogRegister</h3><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/LogRegister.png" alt=""></p><p>这个类的作用，就是让 <code>BeanDefinitionRegistry</code> 将我们的 <code>LogAop</code> 注册成一个Bean，只有当注册成一个 <code>Bean</code> 以后，该切面才会生效。</p><h3 id="LogAop"><a href="#LogAop" class="headerlink" title="LogAop"></a>LogAop</h3><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/how%20to%20define%20a%20annotion/LogAop.png" alt=""></p><p>该类就是一个切面类，负责打印请求的耗时。自此，一个自定义注解就完成了，当第三方想接入该日志log的时候，就可以直接使用 <code>@EnableLog</code> 来开启。</p><blockquote><p>ps：注意调整<code>@Pointcut</code> 的切点，否则会切不到</p></blockquote><p>这就是最简单的自定义注解了，至于里面涉及到的原理，后续可能会写一些文章来补充。</p><p>如果需要查看源代码的话，可以访问如下 <code>github</code> 地址：</p><blockquote><p><a href="https://github.com/Somersames/spring-doc-sample/tree/master/anno-test" target="_blank" rel="noopener">https://github.com/Somersames/spring-doc-sample/tree/master/anno-test</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在SpringBoot中，经常可以看到许多以 &lt;code&gt;@Enable&lt;/code&gt; 开头的注解，例如：&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;，&lt;code&gt;@EnableAsync&lt;/code&gt;……，那么我们是否可以自己定义一个注解呢？
      
    
    </summary>
    
      <category term="Springboot" scheme="https://somersames.github.io/categories/Springboot/"/>
    
    
      <category term="Springboot" scheme="https://somersames.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Springboot的maven间接依赖</title>
    <link href="https://somersames.github.io/2020/05/19/springboot-indirect-maven-rely/"/>
    <id>https://somersames.github.io/2020/05/19/springboot-indirect-maven-rely/</id>
    <published>2020-05-18T16:21:53.000Z</published>
    <updated>2021-04-05T14:52:36.608Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中经常使用 <code>maven</code> 来管理项目，但是有时候对于 <code>maven</code> 的细节还是了解的不是很清楚，因此今天复习下。</p><h2 id="maven项目"><a href="#maven项目" class="headerlink" title="maven项目"></a>maven项目</h2><p>首先开始建立一个最简单的 <code>maven</code> 项目，其配置如下图：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/maven-project.png" alt=""></p><p>可以看到最上面一行是 <code>xml</code> 的文件描述符，然后再是 <code>project</code>，在这里引入 xsd 文件。</p><blockquote><p>XSD(XML Schemas Definition)XML Schema，描述了 xml 文档的结构，用于判断其是否符合 <code>xml</code> 的格式要求</p></blockquote><p>然后下面就是 <code>groupId</code>，通常是公司的域名，<code>artifactId</code> 通常指的是项目名称。</p><h2 id="Springboot项目"><a href="#Springboot项目" class="headerlink" title="Springboot项目"></a>Springboot项目</h2><p>按照官方的指导，在项目中首先引用 <code>spring-boot-starter-parent</code>，修改后的 <code>pom.xml</code> 如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>maven-test<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当准备在启动类上加 <code>@SpringBootApplication</code> 注解的时候，此时 IDEA 会提示找不到这个注解。这是正常的，因为 <code>parent</code> 只是把这个项目的配置和依赖信息统一化了，使得 <code>子pom</code> 就不用关心版本问题，例如在项目中引入<code>spring-boot-starter-web</code>，当配置了 <code>parent</code> 之后，只需要在 <code>子pom</code> 中如下配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>那么它的配置信息就会自动的从 <code>parent</code> 中读取。例如刚刚的<code>spring-boot-starter-web</code>信息，它的版本信息如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/maven-web-version.png" alt=""></p><blockquote><p>tips:使用命令<code>mvn -Dverbose dependency:tree</code>就可以像这样打印 jar 的依赖</p></blockquote><p>那么 springboot 又是怎样来自动识别版本号的呢，此时就就涉及到了<code>spring-boot-dependencies</code></p><h2 id="spring-boot-dependencies"><a href="#spring-boot-dependencies" class="headerlink" title="spring-boot-dependencies"></a>spring-boot-dependencies</h2><p><code>spring-boot-dependencies</code> 是 <code>spring-boot-starter-parent</code> 的一个 parent，可以在 <code>spring-boot-starter-parent</code> 的 <code>pom</code> 文件中看到。<br>打开 <code>spring-boot-dependencies</code> 文件，你会发现它里面几乎全部都是一些配置信息，而刚刚的<code>spring-boot-dependencies</code> 版本号就是来自于此。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/depence-maven.png" alt=""></p><p>到目前为止，可以基本理清 <code>springboot</code> 的依赖关系了。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/pom-relation.png" alt=""></p><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>在工程中，随便写一个 <code>controller</code>，然后执行<code>mvn package</code>，此时会在 <code>target</code> 目录下出现一个 jar 包，然后运行 jar 包，正常启动OK。</p><h2 id="替换parent"><a href="#替换parent" class="headerlink" title="替换parent"></a>替换parent</h2><p>既然 <code>spring-boot-starter-parent</code> 是依赖于 <code>spring-boot-dependencies</code>的，那么可不可以直接将<code>parent</code> 设置为<code>spring-boot-dependencies</code>呢，修改 pom 文件如下:<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/replace-parent.png" alt=""></p><p>然后执行<code>mvn package</code>，执行的时候是成功的，但是当你用 <code>java -jar maven-test.jar</code> 的时候，你会发现提示如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target java -jar maven-test.jar</span><br><span class="line">maven-test.jar中没有主清单属性</span><br></pre></td></tr></table></figure></p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>首先分析下两个的 <code>maven</code> log。</p><h4 id="spring-boot-starter-parent作为parent"><a href="#spring-boot-starter-parent作为parent" class="headerlink" title="spring-boot-starter-parent作为parent"></a><strong>spring-boot-starter-parent作为parent</strong></h4><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/parent-log.png" alt=""></p><h4 id="spring-boot-dependencies作为parent"><a href="#spring-boot-dependencies作为parent" class="headerlink" title="spring-boot-dependencies作为parent"></a><strong>spring-boot-dependencies作为parent</strong></h4><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/maven-project/depence-log.png" alt=""></p><p>可以看到第二次的打包插件是 <code>maven-jar-plugin</code>，也就是说 springboot 的项目一些资源并没有打包进来，查看 <code>spring-boot-maven-plugin</code> 插件，发现它是来自于 <code>spring-boot-starter-parent</code> 里面的，但是在文章的开头部分，是已经手动的将其引入到了 pom 文件，那么修改 parent 以后未执行的话，最有可能就是版本号的缺失导致的，于是修改pom：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">finalName</span>&gt;</span>maven-test<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后运行<code>mvn package</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[INFO] --- spring-boot-maven-plugin:<span class="number">2.1</span>.11.RELEASE:repackage (repackage) @ maven-test ---</span><br><span class="line">[INFO] Replacing main artifact with repackaged archive</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br></pre></td></tr></table></figure></p><p>你会发现此时打包出来的 jar 文件已经可以运行了。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>那么假设项目已经有了自己的 <code>parent</code>，如果还想用 <code>spring-boot-dependencies</code> 来进行统一的一个全局版本控制，那么有如下的解决办法</p><p>在自己的<code>parent</code>中设置parent为 <code>spring-boot-starter-parent</code>，那么根据 maven 的继承属性，所有的 <code>子pom</code> 也就顺带继承了 <code>spring-boot-starter-parent</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在项目中经常使用 &lt;code&gt;maven&lt;/code&gt; 来管理项目，但是有时候对于 &lt;code&gt;maven&lt;/code&gt; 的细节还是了解的不是很清楚，因此今天复习下。&lt;/p&gt;
&lt;h2 id=&quot;maven项目&quot;&gt;&lt;a href=&quot;#maven项目&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Springboot" scheme="https://somersames.github.io/categories/Springboot/"/>
    
    
      <category term="maven" scheme="https://somersames.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>阿里云SDK使用代理的一个坑</title>
    <link href="https://somersames.github.io/2020/05/16/%E9%98%BF%E9%87%8C%E4%BA%91SDK%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/"/>
    <id>https://somersames.github.io/2020/05/16/阿里云SDK使用代理的一个坑/</id>
    <published>2020-05-16T13:25:49.000Z</published>
    <updated>2021-04-05T14:52:36.653Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目中需要使用阿里云的短信平台，所以直接引用了最新的SDK，版本号为 <code>4.5.1</code>。但是由于机器在内网环境，如果需要访问外部网络的话，需要代理机器。于是去看下 阿里的SDK 官方文档，如何支持代理访问，于是找到以下内容：</p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/%E9%98%BF%E9%87%8CSDK%E4%BB%A3%E7%90%86.png" alt=""></p><p>坑就坑在这个文档里面的设置方法，设置了并没有什么用。于是自己研究了下这种设置为什么不生效。</p><h2 id="System-setProperty"><a href="#System-setProperty" class="headerlink" title="System.setProperty"></a>System.setProperty</h2><p>这个命令和在启动参数中加 <code>-DXXX=XXX</code> 是一样的效果，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"http.proxyHost"</span>, <span class="string">"127.0.0.1"</span>); </span><br><span class="line">System.setProperty(<span class="string">"http.proxyPort"</span>, <span class="string">"8888"</span>);</span><br></pre></td></tr></table></figure></p><p>就等价于 <code>-Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort = 8888</code>，但是这种设置有一个限制，那就是只对 JDK 自带的 <code>HttpURLConnection</code> 有效，如下Demo：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/JDK%E7%9A%84Http%E4%BB%A3%E7%90%86.png" alt=""></p><p>当我们执行这段代码的时候，你会发现确实走了代理（可以本地随便设置一个IP加端口，你会发现一直卡在那里），那么既然这是有效的，就说明了阿里云的 Http 请求一定不是通过 JDK 的 <code>HttpURLConnection</code> 发送的。</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>在阿里 <code>doCommonResponse</code> 的调用链路中，发现有一处代码 <code>com.aliyuncs.DefaultAcsClient#doRealAction</code> 如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/ali-http-proxy.png" alt=""></p><p>此时阿里的SDK会通过 <code>System.getenv(&quot;HTTPS_PROXY&quot;)</code> 和 <code>System.getenv(&quot;HTTP_PROXY&quot;)</code> 来判断系统的环境中是否有如下两个变量。有的话就设置到 <code>HttpClientConfig</code> 中，没有的话则直接  return，既然我们系统环境里面没有这两个字段，那么肯定不会设置代理，于是继续往下跟代码。</p><p>最终发送 Http 请求的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IHttpClient httpClient;</span><br><span class="line">...省略相关代码</span><br><span class="line"><span class="comment">// com.aliyuncs.DefaultAcsClient#doRealAction 第330行</span></span><br><span class="line">response = <span class="keyword">this</span>.httpClient.syncInvoke(httpRequest);</span><br></pre></td></tr></table></figure></p><p><code>httpClient</code> 最终对应的是 <code>IHttpClient</code>，它是阿里 SDK 里面的一个类。</p><h3 id="IHttpClient"><a href="#IHttpClient" class="headerlink" title="IHttpClient"></a>IHttpClient</h3><p>首先看下它的结构。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/ali-class-struct.png" alt=""></p><p>在这边有两个实现类，<code>ApacheHttpClient</code> 是 apache 下面的一个包，而 <code>CompatibleUrlConnClient</code> 则是 JDK 自带的 http 请求类，那么阿里的SDK到底是初始化那一个SDK呢？</p><p>首先查看官方的发送短信Demo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... 省略相关代码</span><br><span class="line">IClientProfile profile = DefaultProfile.getProfile(<span class="string">"cn-hangzhou"</span>, accessKeyId,</span><br><span class="line">accessKeySecret);</span><br><span class="line">IAcsClient acsClient = <span class="keyword">new</span> DefaultAcsClient(profile);</span><br></pre></td></tr></table></figure></p><p><code>new DefaultAcsClient(profile)</code> 这行代码最终会调用<br><code>com.aliyuncs.DefaultAcsClient#DefaultAcsClient(com.aliyuncs.profile.IClientProfile, com.aliyuncs.auth.AlibabaCloudCredentialsProvider)</code> 这个构造器。</p><p>而且在这一行代码里面会进行 <code>HttpClientConfig</code> 的初始化，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultAcsClient</span><span class="params">(IClientProfile profile, AlibabaCloudCredentialsProvider credentialsProvider)</span> </span>&#123;</span><br><span class="line">... 省略相关代码</span><br><span class="line">    <span class="keyword">this</span>.httpClient = HttpClientFactory.buildClient(<span class="keyword">this</span>.clientProfile);</span><br><span class="line">... 省略相关代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/default-config.png" alt=""></p><p> 而在 <code>HttpClientConfig.getDefault()</code> 里面，最终会默认初始化一个 Apache 的 Httpclient。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpClientConfig <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpClientConfig config = <span class="keyword">new</span> HttpClientConfig();</span><br><span class="line">    config.setClientType(HttpClientType.ApacheHttpClient);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此为什么官方文档上写的 <code>System.setProperty</code> 不生效的原因终于找到了。也就是说，如果你是按照官方文档来写的代码，那么你通过 <code>System.setProperty</code> 来设置代理是肯定不是生效的。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>将<code>HTTPS_PROXY</code> 或者 <code>HTTP_PROXY</code> 设置为系统环境变量（可以生效，但是不推荐）</li><li>在 <code>buildClient</code> 方法里面，可以发现只有当 <code>HttpClientConfig</code> 为空的情况下才会创建默认的 config，那么我们可以在 <code>IClientProfile</code> 里面，手动的将 <code>HttpClientConfig</code> 设置进去，从而避免创建默认的<code>HttpClientConfig</code>。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E9%98%BF%E9%87%8CSDK%E7%9A%84%E5%9D%91/solve-plan.png" alt=""></li><li>用 JDK 的 <code>HttpURLConnection</code> 发请求，通过 <code>System.setProperty</code> 设置代理。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于项目中需要使用阿里云的短信平台，所以直接引用了最新的SDK，版本号为 &lt;code&gt;4.5.1&lt;/code&gt;。但是由于机器在内网环境，如果需要访问外部网络的话，需要代理机器。于是去看下 阿里的SDK 官方文档，如何支持代理访问，于是找到以下内容：&lt;/p&gt;
&lt;p&gt;&lt;img 
      
    
    </summary>
    
      <category term="阿里云" scheme="https://somersames.github.io/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    
      <category term="Java" scheme="https://somersames.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>记一次parallelStream错误使用导致的NullPointerException</title>
    <link href="https://somersames.github.io/2020/05/11/%E8%AE%B0%E4%B8%80%E6%AC%A1parallelStream%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84NullPointerException/"/>
    <id>https://somersames.github.io/2020/05/11/记一次parallelStream错误使用导致的NullPointerException/</id>
    <published>2020-05-10T16:21:13.000Z</published>
    <updated>2021-04-05T14:52:36.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="parallelStream"><a href="#parallelStream" class="headerlink" title="parallelStream"></a>parallelStream</h2><p>在 Java8 中，新增了一个很有用的功能就是 <code>流</code>，这个功能可以使我们可以快速的写出优雅的代码，其中 <code>stream</code> 是一个串行流（说法可能有误…就是不会采取多线程来进行处理）。还有一种就是 <code>parallelStream</code> 采用 <code>ForkJoinPool</code> 来实现并发，加快执行效率。</p><p>所以在使用 <code>parallelStream</code> 的时候一定要注意线程安全的问题，首先看一段代码：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E8%AE%B0%E4%B8%80%E6%AC%A1parallelStream%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84NullPointerException/%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.png" alt=""></p><p>在这段代码中，是首先判断 <code>dataListList</code> 里面对象的 <code>name</code> 属性是否是偶数，是的话则添加至偶数List，反之则添加至奇数List。</p><p>然后开始测试这段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      DataListTest.test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行一段时间你就会发现，会出现 <code>NullPointerException</code>，这是因为在之前的 <code>forEach</code> 里面 ArrayList 是一个非线程安全的集合，而 <code>parallelStream</code> 是一个多线程的流，所以就会导致 <code>ArrayList</code> 在并发插入的时候，会出现部分元素是null的情况。具体原因如下：</p><h2 id="ArrayList并发不安全"><a href="#ArrayList并发不安全" class="headerlink" title="ArrayList并发不安全"></a>ArrayList并发不安全</h2><p>ArrayList并发不安全的点在于 <code>add</code> 方法里面没有使用锁来保证线程安全，下面是 add 的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设不慎将 <code>ArrayList</code> 用于并发的环境，那么当第一个线程读取到 size 是 0，第二个线程也读取到该 size 也是0，然后都执行完了 <code>ensureCapacityInternal</code> 方法，此时线程一执行完 <code>size++</code> 后被挂起，然后线程二也执行了 <code>size++</code>，那么此时无论哪一个线程先执行数组的赋值操作，它的值一定会被另一个线程所覆盖。</p><blockquote><p>回到上面并发流空指针那一个例子</p></blockquote><p>出现异常情况的 <code>List</code> 如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E8%AE%B0%E4%B8%80%E6%AC%A1parallelStream%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84NullPointerException/List%E4%B8%BAnull.png" alt=""></p><p>然后在 <code>Collectors.toMap()</code> 方法里面最终会调用到 HashMap 的 merge 方法，而 HashMap 的 merge 方法第一行就是判断 <code>value</code> 是否为空，所以就导致了 <code>NullPointerException</code></p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/%E8%AE%B0%E4%B8%80%E6%AC%A1parallelStream%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84NullPointerException/merge%E4%B8%BA%E7%A9%BA.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用 <code>parallelStream</code> 一定需要注意并发的安全，同时注意在重构代码的时候如果是这种并发流的话，一定要注意线程安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;parallelStream&quot;&gt;&lt;a href=&quot;#parallelStream&quot; class=&quot;headerlink&quot; title=&quot;parallelStream&quot;&gt;&lt;/a&gt;parallelStream&lt;/h2&gt;&lt;p&gt;在 Java8 中，新增了一个很有用的功能就
      
    
    </summary>
    
      <category term="Java" scheme="https://somersames.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://somersames.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>WeakHashMap的实现原理</title>
    <link href="https://somersames.github.io/2020/04/22/WeakHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://somersames.github.io/2020/04/22/WeakHashMap的实现原理/</id>
    <published>2020-04-21T16:29:25.000Z</published>
    <updated>2021-04-05T14:52:36.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是WeakHashMap"><a href="#什么是WeakHashMap" class="headerlink" title="什么是WeakHashMap"></a>什么是WeakHashMap</h2><p>WeakHashMap实现了 Map 接口，属于 Java 集合中的一员，其用法几乎和 HashMap 一致，但是由于它的 Entry 还继承了 WeakHashMap ，因此导致它的这个 Entry 在触发 FullGc 的时候是有可能可以被回收的。</p><blockquote><p><strong>以下测试，JVM参数统一为：-Xmx64M -Xms64M -XX:+PrintGCDetails</strong></p></blockquote><p>首先上一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;<span class="keyword">byte</span>[][],<span class="keyword">byte</span>[][]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">byte</span>[][] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line">    map.put(b,<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>][<span class="number">1024</span>]);</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很快就会看到程序抛出了 <code>OOM异常</code></p><p>修改程序为 <code>WeakHashMap</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WeakHashMap&lt;<span class="keyword">byte</span>[][],<span class="keyword">byte</span>[][]&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">byte</span>[][] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line">    map.put(b,<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>][<span class="number">1024</span>]);</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你会看到程序运行了很久都没有停下，那么证明了 <code>WeakHashMap</code> 确实会对一些没有其他引用的 key 进行删除了，那么此时如果将程序的代码再次修改下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WeakHashMap&lt;<span class="keyword">byte</span>[][],<span class="keyword">byte</span>[][]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    WeakHashMap&lt;<span class="keyword">byte</span>[][],<span class="keyword">byte</span>[][]&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">byte</span>[][] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line">    map.put(b,<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>][<span class="number">1024</span>]);</span><br><span class="line">    list.add(map);</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时也会很快的出现了 <code>OOM</code>异常。此时你心里可能会想的是 List 含有了对 WeakReference 的强引用，导致 GC 无法回收对象，但是这里需要注意的是，虽然 List 含有对 WeakHashMap 的强引用，但是 WeakHashMap 的Entry 是继承了 WeakReference 的。因此当 调用 <code>System.gc()</code> 的时候，WeakHashMap 的 Entry 由于没有地方引用，应该是要被回收的。</p><p>为了证实 <code>WeakHashMap</code> 的 key 确实是被 GC 回收了，下面再来看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WeakHashMap&lt;<span class="keyword">byte</span>[][],Object&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    WeakHashMap&lt;<span class="keyword">byte</span>[][],Object&gt; map = <span class="keyword">new</span> WeakHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">byte</span>[][] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>][<span class="number">1024</span>];</span><br><span class="line">    map.put(b,<span class="keyword">new</span> Object());</span><br><span class="line">    list.add(map);</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时将 WeakHashMap 的value 修改为一个小对象，你会发现再次运行的话，运行很长时间都不会出现 OOM 异常了。</p><p>那么在看了上面这么多的例子之后，说明 <code>WeakHashMap</code> 的 Entry 肯定是可以被回收的，但是具体如何被回收还是得看下源代码。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="eg1"><a href="#eg1" class="headerlink" title="eg1"></a>eg1</h3><p>首先 HashMap 因为持有其对象的强引用，所以导致 GC 无法将其回收，从而导致了 OOM 异常。</p><h3 id="eg2"><a href="#eg2" class="headerlink" title="eg2"></a>eg2</h3><p>WeakHashMap 在运行了很长时间以后，一直未出现 OOM 异常，那么说明了其内部肯定有一些的操作来回收不可达对象。那么下面就来分析为什么会被回收。</p><h4 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h4><p><code>WeakHashMap</code> 和 <code>HashMap</code> 的大致结构是一样的，但是有一个区别是，<code>WeakHashMap</code>在实现了<code>Map.Entry&lt;K,V&gt;</code> 的时候还继承了 <code>WeakReference&lt;Object&gt;</code> 。如下图所示：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/WeakHashMap/WeakHashMap-Entry.png" alt=""></p><p>可以看到，此时 <code>Entry&lt;K,V&gt;</code> 的 key 是继承了 <code>WeakReference</code> 的，所以在 System.gc 的时候，key是一定可以被GC的，那么还有一个就是 value 是如何被 GC 的，此时查看 put 方法：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/WeakHashMap/WeakHashMap-put.png" alt=""></p><p>在这里需要注意的是 </p><blockquote><p>Entry&lt;K,V&gt;[] tab = getTable();</p></blockquote><p>这一行代码是会通过 <code>ReferenceQueue</code> 来判断哪些 key 是可以被回收的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line">                    <span class="comment">// Must not null out e.next;</span></span><br><span class="line">                    <span class="comment">// stale entries may be in use by a HashIterator</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 <code>queue.poll()</code> 方法来获取被 GC 回收后的key，然后通过对key进行 hash ，取出下标，移动指针，将value 置为 null ，然后结束。至此，为什么 eg2 不会出现 OOM 的结果就出现了，那是因为 <code>WeakHashMap</code> 在进行 put 的之后，还手动调用了一次 System.gc，然后在 put 的时候调用了 <code>expungeStaleEntries</code> 方法，所以 GC 就可以把那些对象回收了。</p><h2 id="eg3和eg4"><a href="#eg3和eg4" class="headerlink" title="eg3和eg4"></a>eg3和eg4</h2><p>对于这两个例子，主要是因为在 for 循环里面是每一次直接 new 了一个 <code>WeakHashMap</code>，而且都是首次调用 put 方法，之后就没有进行任何处理。因此首次 put 进去的数据，无法触发 <code>expungeStaleEntries</code>，因此导致只有 key 可以被回收，而 value 则是无法被回收的（expungeStaleEntries 方法里面手动将 value 置为了 null，导致可以被 GC）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;什么是WeakHashMap&quot;&gt;&lt;a href=&quot;#什么是WeakHashMap&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Java" scheme="https://somersames.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://somersames.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>代理模式之JDK为什么需要实现接口(下篇)</title>
    <link href="https://somersames.github.io/2020/04/21/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B9%8BJDK%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-%E4%B8%8B%E7%AF%87/"/>
    <id>https://somersames.github.io/2020/04/21/代理模式之JDK为什么需要实现接口-下篇/</id>
    <published>2020-04-20T17:00:44.000Z</published>
    <updated>2021-04-05T14:52:36.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上篇主要介绍了 JDK 动态代理执行的一些流程，通过 Proxy 类来实现生成新的代理类，在这一篇主要讲的是 Proxy 是如何来生成以及缓存生成的代理类</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>在上一篇的结尾提到过了一个map，其结构如下：</p><blockquote><p>ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier<v>&gt;&gt;</v></p></blockquote><p>在这里可以看到是两个 <code>ConcurrentMap</code> 来实现的嵌套，那么 Java 为什么要这样设计呢？首先查看 <code>CacheKey</code> 的代码。如下：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/CacheKey%E7%9A%84%E7%94%9F%E6%88%90.png" alt=""></p><p>可以看到 <code>CacheKey</code> 是继承自 WeakReference，以便于当该 <code>CacheKey</code> 没人使用的时候可以让 GC 直接回收。<code>ReferenceQueue</code> 是 WeakReference 所使用的。</p><p>那么对于 Java 来讲，其是用一个 classLoader 为 key 的 cacheKey 来生成一个 key，这个key就是二级缓存的第一个key。回到上述的map。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/map%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98.png" alt=""></p><p>可以看到在首次初始化的时候，map 还是会以刚刚的 <code>cacheKey</code> 来获取二级缓存，但是首次一定是空的，所以此时直接 new 了一个 <code>ConcurrentMap</code> 作为 <code>value</code> 来放入二级缓存。<br>再往下看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br></pre></td></tr></table></figure></p><p>这是一个 Java8 的 lambda 表达式，查看这个表达式实现的地方：<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/keyFactory.png" alt=""></p><p><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/KeyX%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png" alt=""></p><p>上面的 <code>KeyX</code> 的作用是用被代理的人所实现的接口进行hash，同时将它们实现的接口放入 <code>refs</code>，这个<code>refs</code>是一个数组，</p><blockquote><p>这个 refs 和 WeakReference 有关，主要是用于当 WeakReference 的对象被回收的时候作为一个监听</p></blockquote><p>此时这个 subKey 已经生成了，那么接下来就是</p><blockquote><p> Supplier<v> supplier = valuesMap.get(subKey);</v></p></blockquote><p>这个也是 Java8 的 lambda 函数，具体作用是通过调用其 get 方法，可以快读的执行函数，但是这里，这个 <code>supplier</code> 是由 <code>Factory</code> 所实现的。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/supplier.png" alt=""></p><p>这一段代码的具体逻辑是，当 <code>supplier</code> 不为空的时候就直接通过 <code>get</code> 方法获取其 value，然后返回，但是如果为 <code>null</code> 的话，那么首先就要初始化一个 <code>Factory</code>，然后在这期间，如果有现成将 <code>supplier</code> 赋值了，那么此时就会进行空判断，如果替换 <code>valueMap</code> 成功，则直接返回刚刚生成的 <code>factory</code>，否则返回 <code>valueMap</code> 里面的值。</p><p>在这里需要注意的是这个 value 就是一个代理类的的类名称。</p><h2 id="代理类生成"><a href="#代理类生成" class="headerlink" title="代理类生成"></a>代理类生成</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// serialize access</span></span><br><span class="line">    <span class="comment">// re-check</span></span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// something changed while we were waiting:</span></span><br><span class="line">        <span class="comment">// might be that we were replaced by a CacheValue</span></span><br><span class="line">        <span class="comment">// or were removed because of failure -&gt;</span></span><br><span class="line">        <span class="comment">// return null to signal WeakCache.get() to retry</span></span><br><span class="line">        <span class="comment">// the loop</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else still us (supplier == this)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// create new value</span></span><br><span class="line">    V value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// remove us on failure</span></span><br><span class="line">            valuesMap.remove(subKey, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the only path to reach here is with non-null value</span></span><br><span class="line">    <span class="keyword">assert</span> value != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrap value with CacheValue (WeakReference)</span></span><br><span class="line">    CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put into reverseMap</span></span><br><span class="line">    reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span><br><span class="line">    <span class="keyword">if</span> (!valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span><br><span class="line">    <span class="comment">// wrapped by it</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有一个重要的方法就是 <code>Factory.get()</code>，该方法由 <code>synchronized</code> 修饰，是用于生成代理类的 class 文件的。而生成代理类的方法在 <code>ProxyClassFactory</code> 的 apply 里面。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">       <span class="comment">// ...... 省略</span></span><br><span class="line">        <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...... 省略</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;</span><br><span class="line">            String name = intf.getName();</span><br><span class="line">            <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...... 省略</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">        proxyName, interfaces, accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                            proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">         * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">         * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">         * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">         * exceeded).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里有几个重要的方法说下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否是接口，这也是为什么 JDK动态代理必须实现一个接口了，因为不是接口的话这个地方验证过不去</span></span><br><span class="line"><span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至于生成的类，可以通过生成文件来查看了。当生成完 class 文件之后，回到 <code>Proxy.newProxyInstance</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line"><span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line"><span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br></pre></td></tr></table></figure><p>在这里是将参数上的 <code>InvocationHandler</code> 通过构造器将代理类中的 <code>InvocationHandler</code> 赋值，从而使用<br><code>invoke</code> 方法来实现代理。</p><h2 id="生成的代理类"><a href="#生成的代理类" class="headerlink" title="生成的代理类"></a>生成的代理类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> design_model.proxy.jdk.Car;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"design_model.proxy.jdk.Car"</span>).getMethod(<span class="string">"run"</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上篇主要介绍了 JDK 动态代理执行的一些流程，通过 Proxy 类来实现生成新的代理类，在这一篇主要讲的是 Proxy 是如何来生成以及
      
    
    </summary>
    
      <category term="Java" scheme="https://somersames.github.io/categories/Java/"/>
    
    
      <category term="动态代理" scheme="https://somersames.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>代理模式之JDK为什么需要实现接口(上篇)</title>
    <link href="https://somersames.github.io/2020/04/15/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%B9%8BJDK%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-%E4%B8%8A%E7%AF%87/"/>
    <id>https://somersames.github.io/2020/04/15/代理模式之JDK为什么需要实现接口-上篇/</id>
    <published>2020-04-15T14:58:59.000Z</published>
    <updated>2021-04-05T14:52:36.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先代理模式分为静态代理和动态代理，由于JDK采用的是动态代理，所以静态代理在这里不再介绍。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>首先<code>JDK</code>的动态代理要求真实的对象必须实现一个接口，而代理类则实现<code>InvocationHandler</code>接口来完成动态代理。如下代码：</p><blockquote><p>接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">jdkProxy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>被代理的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jdkProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"测试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>代理类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before---------"</span>);</span><br><span class="line">        Object object = method.invoke(target,args);</span><br><span class="line">        System.out.println(<span class="string">"after---------"</span>);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">new</span> SelfClassLoader(),clazz.getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代理模式中真实对象继承一个接口如果说是为了在代理类中统一管理，那么在 <code>JDK动态代理</code> 中如果被代理的对象还必须实现一个接口就有点繁琐了，但是对于 Java 语言来说其实也没办法。我们都认为很繁琐的一个实现，JDK 开发人员应该也会想到这一点。</p><p>下面就来解释下为什么动态代理必须实现一个接口。</p><h4 id="为什么必须实现一个接口"><a href="#为什么必须实现一个接口" class="headerlink" title="为什么必须实现一个接口"></a>为什么必须实现一个接口</h4><p>在回答这个问题之前，首先要说明的是 <code>JDK动态代理</code> 实现的原理是重新为对象类生成了一个子类，这个类由于是 JDK 自己生成的，于是会以<code>$</code>开头，在 JDK 文档中有如下说明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A proxy class has the following properties:</span><br><span class="line"></span><br><span class="line">Proxy classes are <span class="keyword">public</span>, <span class="keyword">final</span>, and not <span class="keyword">abstract</span>.</span><br><span class="line">The unqualified name of a proxy class is unspecified. The space of class names that begin with the string "$Proxy" should be, however, reserved for proxy classes.</span><br><span class="line">A proxy <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">reflect</span>.<span class="title">Proxy</span>.</span></span><br></pre></td></tr></table></figure></p><p>其实还有很多说明，但是涉及到本文的也就上面三条。</p><ol><li>proxy类是非抽象类，且由<code>public final</code>修饰。</li><li>proxy类是以<code>$Proxy</code>开头的加类的名称。</li><li>proxy类是<code>java.lang.reflect.Proxy</code>的子类。</li></ol><p>那么既然是<code>$Proxy</code>开头的，那么是否可以将生成的子类打印出来呢？，如下代码：</p><p>可以看到这个新生成的类其实是直接继承了 <code>Proxy</code> 类，由于Java的单继承方式，此时如果要获取对象类里面的方法那么就必须实现一个接口，所以也就对象类必须要实现一个接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car car = (Car) <span class="keyword">new</span> ProxyTest().getInstance(<span class="keyword">new</span> Bus());</span><br></pre></td></tr></table></figure></p><p>那么当我们执行这个代码的时候究竟在执行什么呢？在这里 debug 来跟踪源码解释 JDK 到底是如何生产 Proxy 代理类的.</p><blockquote><p>newProxyInstance方法<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/newProxyInstance.png" alt=""></p></blockquote><p>在这个方法里面，目前暂时需要注意红框中的方法，代理类是在该方法里面是生成的。</p><p><code>Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</code> 这一行代码，在这里返回的是一个 class，然后通过反射来初始化这个 class，最后这个 class 就是 JDK 生成的代理类。</p><blockquote><p>getProxyClass0</p></blockquote><p>而在 <code>getProxyClass0</code> 方法里面就是通过 <code>proxyClassCache.get(loader, interfaces)</code>来获取 Proxy，如果里面包含该 classLoader 加载的 interface 的话，则直接返回，否则就是再初始化一次，然后返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>proxyClassCache.get(loader, interfaces)</p></blockquote><p>从这个方法之后就是真正开始生成 Proxy 类的过程，由于这里面包含一些 Java8 的 lambda表达式 用法，对于不太了解的人可能会有点看不懂。<br><img src="https://szhtc-1252780558.cos.ap-shanghai.myqcloud.com/%E6%96%87%E7%AB%A0/proxy.png" alt=""></p><p>上面的图给出了初始化 map 的一个方法，在这里需要注意的是，这个map的结构如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map</span><br><span class="line">        = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>也就是一个两层的 ConcurrentMap，而之所以为为什么这样设计是跟实现的接口相关的，是由于第一层的 key 是由 classLoader 所生成的 key，而第二层测试keyX，与所实现的接口有关。<br>剩下的将会在下一篇文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;首先代理模式分为静态代理和动态代理，由于JDK采用的是动态代理，所以静态代理在这里不再介绍。&lt;/p&gt;
&lt;h2 id=&quot;动态代理&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Java" scheme="https://somersames.github.io/categories/Java/"/>
    
    
      <category term="动态代理" scheme="https://somersames.github.io/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>重温Java中String</title>
    <link href="https://somersames.github.io/2020/04/06/%E9%87%8D%E6%B8%A9Java%E4%B8%ADString/"/>
    <id>https://somersames.github.io/2020/04/06/重温Java中String/</id>
    <published>2020-04-06T13:41:39.000Z</published>
    <updated>2021-04-05T14:52:36.653Z</updated>
    
    <content type="html"><![CDATA[<p>本文的内容都是基于 JDK1.8 来写的，主要是复习下 String 类的设计。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>String 是一个用于存储字符串的类，其内部是通过 char 数组来实现，在 Java 中，1byte = 8bit，1char = 2byte, 所以在 Java 中，String 的code point是16位。<br>String 类是由 final 关键字来修饰的，因此表明该类不可以被继承，同时 String 又实现了 Serializable、Comparable、CharSequence接口，表明 String 可以被序列化，以及使用cpmpareTo来比较两个字符串的值。</p><h2 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h2><h3 id="内码"><a href="#内码" class="headerlink" title="内码"></a>内码</h3><p>内码指的是程序内部自己使用的字符集，java中是以 <code>UTF-16</code> 来表示的</p><blockquote><p>The Java programming language represents text in sequences of 16-bit code units, using the UTF-16 encoding.</p></blockquote><p>UTF-16最多可以表示 65535 种字符，那么不在 65535 之内的字符，该如何表示呢，这时候就需要用两个字节来表示这个字符。以😁这个emoje为例子：其Code的编码是<code>1F601</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">具体方法是：</span><br><span class="line"></span><br><span class="line">Code Point减去<span class="number">0x10000</span>， 得到的值是长度为<span class="number">20</span>bit（不足的补<span class="number">0</span>）；</span><br><span class="line">将得到数值的高位的<span class="number">10</span>比特的值 加上<span class="number">0xD800</span>的前<span class="number">6</span>位得到第一个Code Unit。</span><br><span class="line">步骤<span class="number">1</span>得到数值的低位的<span class="number">10</span>比特的值 加上<span class="number">0xDC00</span>的前<span class="number">6</span>位得到第二个Code Unit。</span><br></pre></td></tr></table></figure></p><p>于是计算方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1F</span>601 - <span class="number">0x10000</span> = <span class="number">1111011000000001</span></span><br><span class="line">不满<span class="number">20</span>位的补<span class="number">0</span>；</span><br><span class="line">所以得到：<span class="number">00001111011000000001</span>。</span><br><span class="line"><span class="number">0xD800</span>：<span class="number">1101100000000000</span></span><br><span class="line"><span class="number">0xDC00</span>：<span class="number">1101110000000000</span></span><br><span class="line">于是高位的代理就是：<span class="number">1101100000111101</span></span><br><span class="line">于是低位的代理就是：<span class="number">1101111000000001</span></span><br><span class="line">最终得到：d83d,de01</span><br></pre></td></tr></table></figure></p><p>在 String 的代码中体现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(CharSequence seq, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c1 = seq.charAt(index);</span><br><span class="line">    <span class="keyword">if</span> (isHighSurrogate(c1) &amp;&amp; ++index &lt; seq.length()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c2 = seq.charAt(index);</span><br><span class="line">        <span class="keyword">if</span> (isLowSurrogate(c2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> toCodePoint(c1, c2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">toCodePoint</span><span class="params">(<span class="keyword">char</span> high, <span class="keyword">char</span> low)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Optimized form of:</span></span><br><span class="line">    <span class="comment">// return ((high - MIN_HIGH_SURROGATE) &lt;&lt; 10)</span></span><br><span class="line">    <span class="comment">//         + (low - MIN_LOW_SURROGATE)</span></span><br><span class="line">    <span class="comment">//         + MIN_SUPPLEMENTARY_CODE_POINT;</span></span><br><span class="line">    <span class="keyword">return</span> ((high &lt;&lt; <span class="number">10</span>) + low) + (MIN_SUPPLEMENTARY_CODE_POINT</span><br><span class="line">                                    - (MIN_HIGH_SURROGATE &lt;&lt; <span class="number">10</span>)</span><br><span class="line">                                    - MIN_LOW_SURROGATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意这个high &lt;&lt; 10是因为code转成16进制的时候，还补了4个0<br>当 String 判断是否是一个 code point 的时候，首先会判断是否是高位代理，是的话在判断下一个字节是否是低位代理，是的就通过<code>toCodePoint</code>来推导出原来的code。</p></blockquote><h2 id="readResolve方法"><a href="#readResolve方法" class="headerlink" title="readResolve方法"></a>readResolve方法</h2><p>这个方法是为了保证序列化的时候，避免生成多个 String 对象，首先当一个对象被反序列化的时候，其调用链如下:</p><blockquote><p>ObjectInputStream -&gt; readObject() -&gt; readObject0(boolean unshared) -&gt; readOrdinaryObject(boolean unshared) </p></blockquote><p>在<code>readOrdinaryObject</code>中，主要是需要注意如下两段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Object obj;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">        desc.forClass().getName(),</span><br><span class="line">        <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    handles.lookupException(passHandle) == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">    desc.hasReadResolveMethod())</span><br><span class="line">&#123;</span><br><span class="line">    Object rep = desc.invokeReadResolve(obj);</span><br><span class="line">    <span class="keyword">if</span> (unshared &amp;&amp; rep.getClass().isArray()) &#123;</span><br><span class="line">        rep = cloneArray(rep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rep != obj) &#123;</span><br><span class="line">        <span class="comment">// Filter the replacement object</span></span><br><span class="line">        <span class="keyword">if</span> (rep != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rep.getClass().isArray()) &#123;</span><br><span class="line">                filterCheck(rep.getClass(), Array.getLength(rep));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                filterCheck(rep.getClass(), -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handles.setObject(passHandle, obj = rep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ObjectStreamClass：</span><br><span class="line">readResolveMethod = getInheritableMethod(cl, <span class="string">"readResolve"</span>, <span class="keyword">null</span>, Object.class);</span><br></pre></td></tr></table></figure></p><p>如果没有重写<code>readResolve</code>的话，那么此时便会直接返回<code>newInstance</code> 生成的新对象了。</p><h2 id="final-的使用"><a href="#final-的使用" class="headerlink" title="final 的使用"></a>final 的使用</h2><p>在 String 中，可以看到需要地方使用到了 final 字段，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p><p>这些都好理解，但是其中有一个方法里面的变量名却也使用了final，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOfSupplementary</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Character.isValidCodePoint(ch)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span> hi = Character.highSurrogate(ch);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span> lo = Character.lowSurrogate(ch);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> max = value.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value[i] == hi &amp;&amp; value[i + <span class="number">1</span>] == lo) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里我个人感觉其实是没什么作用的，因为方法内部的<code>value</code>会随着<code>this.value</code>的变化而变化(一般不可能)，所以这里的final，也就<code>hi</code>和<code>lo</code>以及<code>max</code>有作用，可以保证同一个方法内部，<br>在多线程的竞态条件下不改变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的内容都是基于 JDK1.8 来写的，主要是复习下 String 类的设计。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;String 是一个用于存储字符串的类，其内
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot中异步线程的处理</title>
    <link href="https://somersames.github.io/2020/04/02/SpringBoot%E4%B8%AD%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>https://somersames.github.io/2020/04/02/SpringBoot中异步线程的处理/</id>
    <published>2020-04-02T15:46:30.000Z</published>
    <updated>2021-04-05T14:52:36.586Z</updated>
    
    <content type="html"><![CDATA[<p>在工作或者学习的时候，我们都会接触到异步编程，大多数情况下都是通过新建一个线程池，然后调用<code>submit</code>方法或者<code>execute</code>方法来执行。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>, TimeUnit.SECONDS,<span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;());</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"callable"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Future future = executor.submit(callable);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在Springboot中其实也可以这样做，但是不利于后期的维护，加入后期需要把 <code>runable</code> 的方法修改为同步类型的，那么此时就需要大量的改动代码，如果说很多地方都用到的了的话，就会很容易漏掉了一处导致bug的产生。</p><h2 id="Spring的解决方法"><a href="#Spring的解决方法" class="headerlink" title="Spring的解决方法"></a>Spring的解决方法</h2><h3 id="不需要返回值的异步"><a href="#不需要返回值的异步" class="headerlink" title="不需要返回值的异步"></a>不需要返回值的异步</h3><p>其实在Spring中就有类似的解决方法，只不过需要我们自己配置。<br>首先新建一个配置类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"asyncPool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">asyncPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里最好的做法是将其配置到配置文件中，这样以后调整就不需要改动代码，不过此处为了演示，也就直接固定了。</p><blockquote><p>新建一个 <code>Service</code> 测试。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncPool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncPool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayB</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>调用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noReturnAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        asyncService.sayB();</span><br><span class="line">        asyncService.sayA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>新建一个测试类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = AsyncApplication.class)</span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noReturnAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        testService.noReturnAsync();</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在控制台会发现是先打印的 A，然后再打印的 B，所以这里可以肯定确认的是肯定是异步执行的。</p><p>但是一般情况下，有一个业务方法并不是通用的，假如有一个 <code>C</code> 方法，这个方法是 TestServcie 类里面单独一个人使用的，这个情况下如果需要在 TestServicde 里面使用的话，那么就需要通过 Aop 来获取当前的代理对象。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noReturnAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        asyncService.sayB();</span><br><span class="line">        asyncService.sayA();</span><br><span class="line">        C();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncPool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">C</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果这样写的话，C方法就会被当成一个同步方法，于是就需要通过 <code>AopContext.currentProxy()</code> 来切换代理对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AsyncService asyncService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noReturnAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        asyncService.sayB();</span><br><span class="line">        asyncService.sayA();</span><br><span class="line">        ((TestService) AopContext.currentProxy()).C();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncPool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">C</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是使用 <code>((TestService) AopContext.currentProxy()).C()</code> 的话，则必须要新增如下Bean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(org.springframework.scheduling.config.TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME);</span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"exposeProxy"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="需要返回值的异步"><a href="#需要返回值的异步" class="headerlink" title="需要返回值的异步"></a>需要返回值的异步</h3><p>上面介绍的都是不需要返回值的异步方法，那么其实很多场景下都是需要返回值的，此时可以通过如下方法来实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span>(<span class="string">"asyncPool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">futureA</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.currentThread().sleep(<span class="number">1100</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;String&gt;(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>调用方式还是和之前一直，就是最后需要用一个 <code>Future</code> 来接。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noReturnAsync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        Future future = asyncService.futureA();</span><br><span class="line">        asyncService.sayB();</span><br><span class="line">        asyncService.sayA();</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        ((TestService) AopContext.currentProxy()).C();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在工作或者学习的时候，我们都会接触到异步编程，大多数情况下都是通过新建一个线程池，然后调用&lt;code&gt;submit&lt;/code&gt;方法或者&lt;code&gt;execute&lt;/code&gt;方法来执行。如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;tabl
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://somersames.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://somersames.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>ES7中大小写不敏感的模糊匹配</title>
    <link href="https://somersames.github.io/2020/03/20/ES7%E4%B8%AD%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E7%9A%84%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D/"/>
    <id>https://somersames.github.io/2020/03/20/ES7中大小写不敏感的模糊匹配/</id>
    <published>2020-03-20T14:14:24.000Z</published>
    <updated>2021-04-05T14:52:36.568Z</updated>
    
    <content type="html"><![CDATA[<p>在ES7.0中</p><p>如果要实现大小写的模糊查询，则首先必须要自定义 <code>analysis</code>，在自定义的 <code>analysis</code> 里面，如果是针对keyword类型的字段， analysis 要定义成 normalizer，而对于text类型的话，则需要为analyzer。如下演示的是<code>normalizer</code>类型的定义。</p><blockquote><p>新建索引<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"normalizer"</span>: &#123;</span><br><span class="line">        <span class="attr">"self_normalizer"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"custom"</span>,</span><br><span class="line">          <span class="attr">"char_filter"</span>: [],</span><br><span class="line">          <span class="attr">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"asciifolding"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">    <span class="attr">"properties"</span>:&#123;</span><br><span class="line">      <span class="attr">"field_1"</span>:&#123;</span><br><span class="line">        <span class="attr">"type"</span>:<span class="string">"keyword"</span>,</span><br><span class="line">        <span class="attr">"normalizer"</span>: <span class="string">"self_normalizer"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>此时向ES中新增几条数据：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"took"</span>: <span class="number">6</span>,</span><br><span class="line"><span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line"><span class="attr">"_shards"</span>: &#123;</span><br><span class="line"><span class="attr">"total"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"hits"</span>: &#123;</span><br><span class="line"><span class="attr">"total"</span>: &#123;</span><br><span class="line"><span class="attr">"value"</span>: <span class="number">4</span>,</span><br><span class="line"><span class="attr">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"max_score"</span>: <span class="number">1.0</span>,</span><br><span class="line"><span class="attr">"hits"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"_index"</span>: <span class="string">"test_ascii"</span>,</span><br><span class="line"><span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line"><span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line"><span class="attr">"_score"</span>: <span class="number">1.0</span>,</span><br><span class="line"><span class="attr">"_source"</span>: &#123;</span><br><span class="line"><span class="attr">"field_1"</span>: <span class="string">"abc"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"_index"</span>: <span class="string">"test_ascii"</span>,</span><br><span class="line"><span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line"><span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line"><span class="attr">"_score"</span>: <span class="number">1.0</span>,</span><br><span class="line"><span class="attr">"_source"</span>: &#123;</span><br><span class="line"><span class="attr">"field_1"</span>: <span class="string">"ABC"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"_index"</span>: <span class="string">"test_ascii"</span>,</span><br><span class="line"><span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line"><span class="attr">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line"><span class="attr">"_score"</span>: <span class="number">1.0</span>,</span><br><span class="line"><span class="attr">"_source"</span>: &#123;</span><br><span class="line"><span class="attr">"field_1"</span>: <span class="string">"aBC"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">"_index"</span>: <span class="string">"test_ascii"</span>,</span><br><span class="line"><span class="attr">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line"><span class="attr">"_id"</span>: <span class="string">"4"</span>,</span><br><span class="line"><span class="attr">"_score"</span>: <span class="number">1.0</span>,</span><br><span class="line"><span class="attr">"_source"</span>: &#123;</span><br><span class="line"><span class="attr">"field_1"</span>: <span class="string">"Abc"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>可以看到此时的对于<code>field_1</code>，在Es中的值大小写都有的，此时进行模糊查询：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"must"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">                  <span class="attr">"field_1"</span>: &#123;</span><br><span class="line">                    <span class="attr">"value"</span>: <span class="string">"*a*"</span>,</span><br><span class="line">                    <span class="attr">"boost"</span>: <span class="number">1</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"adjust_pure_negative"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"boost"</span>: <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"adjust_pure_negative"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"boost"</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>返回值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"took"</span>: <span class="number">9</span>,</span><br><span class="line"><span class="string">"timed_out"</span>: <span class="keyword">false</span>,</span><br><span class="line"><span class="string">"_shards"</span>: &#123;</span><br><span class="line"><span class="string">"total"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"successful"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="string">"failed"</span>: <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"hits"</span>: &#123;</span><br><span class="line"><span class="string">"total"</span>: &#123;</span><br><span class="line"><span class="string">"value"</span>: <span class="number">4</span>,</span><br><span class="line"><span class="string">"relation"</span>: <span class="string">"eq"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"max_score"</span>: <span class="number">1.0</span>,</span><br><span class="line"><span class="string">"hits"</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_index"</span>: <span class="string">"test_ascii"</span>,</span><br><span class="line"><span class="string">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line"><span class="string">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line"><span class="string">"_score"</span>: <span class="number">1.0</span>,</span><br><span class="line"><span class="string">"_source"</span>: &#123;</span><br><span class="line"><span class="string">"field_1"</span>: <span class="string">"abc"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_index"</span>: <span class="string">"test_ascii"</span>,</span><br><span class="line"><span class="string">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line"><span class="string">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line"><span class="string">"_score"</span>: <span class="number">1.0</span>,</span><br><span class="line"><span class="string">"_source"</span>: &#123;</span><br><span class="line"><span class="string">"field_1"</span>: <span class="string">"ABC"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_index"</span>: <span class="string">"test_ascii"</span>,</span><br><span class="line"><span class="string">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line"><span class="string">"_id"</span>: <span class="string">"3"</span>,</span><br><span class="line"><span class="string">"_score"</span>: <span class="number">1.0</span>,</span><br><span class="line"><span class="string">"_source"</span>: &#123;</span><br><span class="line"><span class="string">"field_1"</span>: <span class="string">"aBC"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"_index"</span>: <span class="string">"test_ascii"</span>,</span><br><span class="line"><span class="string">"_type"</span>: <span class="string">"_doc"</span>,</span><br><span class="line"><span class="string">"_id"</span>: <span class="string">"4"</span>,</span><br><span class="line"><span class="string">"_score"</span>: <span class="number">1.0</span>,</span><br><span class="line"><span class="string">"_source"</span>: &#123;</span><br><span class="line"><span class="string">"field_1"</span>: <span class="string">"Abc"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在ES7.0中&lt;/p&gt;
&lt;p&gt;如果要实现大小写的模糊查询，则首先必须要自定义 &lt;code&gt;analysis&lt;/code&gt;，在自定义的 &lt;code&gt;analysis&lt;/code&gt; 里面，如果是针对keyword类型的字段， analysis 要定义成 normalizer，而
      
    
    </summary>
    
      <category term="ElasticSearch" scheme="https://somersames.github.io/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="https://somersames.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>springboot多数据源-sqlSessionFactory</title>
    <link href="https://somersames.github.io/2020/03/19/springboot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90-sqlSessionFactory/"/>
    <id>https://somersames.github.io/2020/03/19/springboot多数据源-sqlSessionFactory/</id>
    <published>2020-03-19T11:57:04.000Z</published>
    <updated>2021-04-05T14:52:36.608Z</updated>
    
    <content type="html"><![CDATA[<p>在SpringBoot中，动态的切换数据源的方式有两种，一种是通过<code>AbstractRoutingDataSource</code>来通过注解实现，另一种则是通过配置不同的<code>SqlSessionFactory</code>来读取不同文件夹的mapper，从而实现多数据源。<br>代码如下：</p><blockquote><p>DataSourceOneConfig</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"xyz.somersames.dao.one"</span>&#125; ,sqlSessionTemplateRef = <span class="string">"dataSourceOneSqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceOneConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSourceOneT"</span>)</span><br><span class="line">    <span class="comment">// 这里后面加一个T是防止Spring出现skiped mapperFactoryBean 错误，导致无法注入</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.one"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSourceOneSqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">setSqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"dataSourceOneT"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        bean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:mapper/one/*.xml"</span>));</span><br><span class="line">        <span class="keyword">return</span> bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSourceOneTransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">setTransactionManager</span><span class="params">(@Qualifier(<span class="string">"dataSourceOneT"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSourceOneSqlSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">setSqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"dataSourceOneSqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DataSourceTwoConfig</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"xyz.somersames.dao.two"</span>&#125; ,sqlSessionTemplateRef = <span class="string">"dataSourceTwoSqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceTwoConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSourceTwoT"</span>)</span><br><span class="line">    <span class="comment">// 这里后面加一个T是防止Spring出现skiped mapperFactoryBean 错误，导致无法注入</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.two"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSourceTwoSqlSessionFactory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">setSqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"dataSourceTwoT"</span>)</span> DataSource dataSource) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        bean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:mapper/two/*.xml"</span>));</span><br><span class="line">        <span class="keyword">return</span> bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSourceTwoTransactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">setTransactionManager</span><span class="params">(@Qualifier(<span class="string">"dataSourceTwoT"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSourceTwoSqlSessionTemplate"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">setSqlSessionTemplate</span><span class="params">(@Qualifier(<span class="string">"dataSourceTwoSqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当添加了这两个配置以后，dataSourceOneT 会扫描 <code>mapper/one</code> 下面的 xml 文件，而 dataSourceTwoT 会扫描 <code>mapper/two</code> 下面的 xml 文件。<br>然后添加配置文件</p><blockquote><p>application.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8091</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    one:</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">    two:</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">      password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">jdbc:mysql://localhost:3306/test_lock?useSSL=false&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure><p>在这里顺带说一句，SqlSessionFactory 负责打开 SqlSession，一个SqlSession代表的就是一次回话，但是如果你在方法上加了一个 <code>@Transactional</code> 注解，那么这个方法里面的所有数据库操作都会认为是一个SqlSession</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在SpringBoot中，动态的切换数据源的方式有两种，一种是通过&lt;code&gt;AbstractRoutingDataSource&lt;/code&gt;来通过注解实现，另一种则是通过配置不同的&lt;code&gt;SqlSessionFactory&lt;/code&gt;来读取不同文件夹的mapper，
      
    
    </summary>
    
      <category term="SpringBoot" scheme="https://somersames.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://somersames.github.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
